<!DOCTYPE html>
<!-- START: inst/pkgdown/templates/layout.html --><!-- Generated by pkgdown: do not edit by hand --><html lang="en" data-bs-theme="auto">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<title>Introduction to High-Performance Computing in Chapel: All in One View</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="../assets/themetoggle.js"></script><link rel="stylesheet" type="text/css" href="../assets/styles.css">
<script src="../assets/scripts.js" type="text/javascript"></script><!-- mathjax --><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      config: ["MMLorHTML.js"],
      jax: ["input/TeX","input/MathML","output/HTML-CSS","output/NativeMML", "output/PreviewHTML"],
      extensions: ["tex2jax.js","mml2jax.js","MathMenu.js","MathZoom.js", "fast-preview.js", "AssistiveMML.js", "a11y/accessibility-menu.js"],
      TeX: {
        extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
      },
      tex2jax: {
        inlineMath: [['\\(', '\\)']],
        displayMath: [ ['$$','$$'], ['\\[', '\\]'] ],
        processEscapes: true
      }
    });
    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><!-- Responsive Favicon for The Carpentries --><link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="manifest" href="../site.webmanifest">
<link rel="mask-icon" href="../safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="white">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="black">
</head>
<body>
    <header id="top" class="navbar navbar-expand-md top-nav incubator"><svg xmlns="http://www.w3.org/2000/svg" class="d-none"><symbol id="check2" viewbox="0 0 16 16"><path d="M13.854 3.646a.5.5 0 0 1 0 .708l-7 7a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L6.5 10.293l6.646-6.647a.5.5 0 0 1 .708 0z"></path></symbol><symbol id="circle-half" viewbox="0 0 16 16"><path d="M8 15A7 7 0 1 0 8 1v14zm0 1A8 8 0 1 1 8 0a8 8 0 0 1 0 16z"></path></symbol><symbol id="moon-stars-fill" viewbox="0 0 16 16"><path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"></path><path d="M10.794 3.148a.217.217 0 0 1 .412 0l.387 1.162c.173.518.579.924 1.097 1.097l1.162.387a.217.217 0 0 1 0 .412l-1.162.387a1.734 1.734 0 0 0-1.097 1.097l-.387 1.162a.217.217 0 0 1-.412 0l-.387-1.162A1.734 1.734 0 0 0 9.31 6.593l-1.162-.387a.217.217 0 0 1 0-.412l1.162-.387a1.734 1.734 0 0 0 1.097-1.097l.387-1.162zM13.863.099a.145.145 0 0 1 .274 0l.258.774c.115.346.386.617.732.732l.774.258a.145.145 0 0 1 0 .274l-.774.258a1.156 1.156 0 0 0-.732.732l-.258.774a.145.145 0 0 1-.274 0l-.258-.774a1.156 1.156 0 0 0-.732-.732l-.774-.258a.145.145 0 0 1 0-.274l.774-.258c.346-.115.617-.386.732-.732L13.863.1z"></path></symbol><symbol id="sun-fill" viewbox="0 0 16 16"><path d="M8 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"></path></symbol></svg><a class="visually-hidden-focusable skip-link" href="#main-content">Skip to main content</a>
  <div class="container-fluid top-nav-container">
    <div class="col-md-8">
      <div class="large-logo">
        <img id="incubator-logo" alt="Introduction to parallel programming in Chapel" src="../assets/images/incubator-logo.svg"><span class="badge text-bg-warning">
          <abbr title="This lesson is in the alpha phase, which means that it has been taught once and lesson authors are iterating on feedback.">
            <a href="https://cdh.carpentries.org/the-lesson-life-cycle.html#field-testing-alpha-stage" class="external-link alert-link">
              <i aria-hidden="true" class="icon" data-feather="alert-triangle" style="border-radius: 5px"></i>
              Alpha
            </a>
            <span class="visually-hidden">This lesson is in the alpha phase, which means that it has been taught once and lesson authors are iterating on feedback.</span>
          </abbr>
        </span>

      </div>
    </div>
    <div class="selector-container">
      <div id="theme-selector">
        <li class="nav-item dropdown" id="theme-button-list">
          <button class="btn btn-link nav-link px-0 px-lg-2 dropdown-toggle d-flex align-items-center" id="bd-theme" type="button" aria-expanded="false" data-bs-toggle="dropdown" data-bs-display="static" aria-label="Toggle theme (auto)">
            <svg class="bi my-1 theme-icon-active"><use href="#circle-half"></use></svg><i data-feather="chevron-down"></i>
          </button>
          <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="bd-theme-text">
<li>
              <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="light" aria-pressed="false">
                <svg class="bi me-2 theme-icon"><use href="#sun-fill"></use></svg>
                Light
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
            <li>
              <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="dark" aria-pressed="false">
                <svg class="bi me-2 theme-icon"><use href="#moon-stars-fill"></use></svg>
                Dark
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
            <li>
              <button type="button" class="btn dropdown-item d-flex align-items-center active" data-bs-theme-value="auto" aria-pressed="true">
                <svg class="bi me-2 theme-icon"><use href="#circle-half"></use></svg>
                Auto
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
          </ul>
</li>
      </div>

      <div class="dropdown" id="instructor-dropdown">
        <button class="btn btn-secondary dropdown-toggle bordered-button" type="button" id="dropdownMenu1" data-bs-toggle="dropdown" aria-expanded="false">
          <i aria-hidden="true" class="icon" data-feather="eye"></i> Instructor View <i data-feather="chevron-down"></i>
        </button>
        <ul class="dropdown-menu" aria-labelledby="dropdownMenu1">
<li><button class="dropdown-item" type="button" onclick="window.location.href='../aio.html';">Learner View</button></li>
        </ul>
</div>
    </div>
  </div>
  <hr></header><nav class="navbar navbar-expand-xl bottom-nav incubator" aria-label="Main Navigation"><div class="container-fluid nav-container">
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle Navigation">
      <span class="navbar-toggler-icon"></span>
      <span class="menu-title">Menu</span>
    </button>
    <div class="nav-logo">
      <img class="small-logo" alt="Introduction to parallel programming in Chapel" src="../assets/images/incubator-logo-sm.svg">
</div>
    <div class="lesson-title-md">
      Introduction to High-Performance Computing in Chapel
    </div>
    <div class="search-icon-sm">
      <!-- TODO: do not show until we have search
        <i role="img" aria-label="Search the All In One page" data-feather="search"></i>
      -->
    </div>
    <div class="desktop-nav">
      <ul class="navbar-nav me-auto mb-2 mb-lg-0">
<li class="nav-item">
          <span class="lesson-title">
            Introduction to High-Performance Computing in Chapel
          </span>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../instructor/key-points.html">Key Points</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../instructor/instructor-notes.html">Instructor Notes</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../instructor/images.html">Extract All Images</a>
        </li>
        <li class="nav-item dropdown">
          <button class="nav-link dropdown-toggle" id="navbarDropdown" data-bs-toggle="dropdown" aria-expanded="false">
            More <i data-feather="chevron-down"></i>
          </button>
          <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
<hr>
<li><a class="dropdown-item" href="reference.html">Reference</a></li>
          </ul>
</li>
      </ul>
</div>
    <!--
    <form class="d-flex col-md-2 search-form">
      <fieldset disabled>
      <input class="form-control me-2 searchbox" type="search" placeholder="" aria-label="">
        <button class="btn btn-outline-success tablet-search-button"  type="submit">
          <i class="search-icon" data-feather="search" role="img" aria-label="Search the All In One page"></i>
        </button>
      </fieldset>
    </form>
    -->
    <a id="search-button" class="btn btn-primary" href="../instructor/aio.html" role="button" aria-label="Search the All In One page">Search the All In One page</a>
  </div>
<!--/div.container-fluid -->
</nav><div class="col-md-12 mobile-title">
  Introduction to High-Performance Computing in Chapel
</div>

<aside class="col-md-12 lesson-progress"><div style="width: %" class="percentage">
    %
  </div>
  <div class="progress incubator">
    <div class="progress-bar incubator" role="progressbar" style="width: %" aria-valuenow="" aria-label="Lesson Progress" aria-valuemin="0" aria-valuemax="100">
    </div>
  </div>
</aside><div class="container">
      <div class="row">
        <!-- START: inst/pkgdown/templates/navbar.html -->
<div id="sidebar-col" class="col-lg-4">
  <div id="sidebar" class="sidebar">
      <nav aria-labelledby="flush-headingEleven"><button role="button" aria-label="close menu" alt="close menu" aria-expanded="true" aria-controls="sidebar" class="collapse-toggle" data-collapse="Collapse " data-episodes="Episodes ">
          <i class="search-icon" data-feather="x" role="img"></i>
        </button>
        <div class="sidebar-inner">
          <div class="row mobile-row" id="theme-row-mobile">
            <div class="col" id="theme-selector">
              <li class="nav-item dropdown" id="theme-button-list">
                <button class="btn btn-link nav-link px-0 px-lg-2 dropdown-toggle d-flex align-items-center" id="bd-theme" type="button" aria-expanded="false" data-bs-toggle="dropdown" data-bs-display="static" aria-label="Toggle theme (auto)">
                  <svg class="bi my-1 theme-icon-active"><use href="#circle-half"></use></svg><span class="d-lg-none ms-1" id="bd-theme-text">Toggle Theme</span>
                </button>
                <ul class="dropdown-menu dropdown-menu-right" aria-labelledby="bd-theme-text">
<li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="light" aria-pressed="false">
                      <svg class="bi me-2 theme-icon"><use href="#sun-fill"></use></svg>
                      Light
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                  <li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="dark" aria-pressed="false">
                      <svg class="bi me-2 theme-icon"><use href="#moon-stars-fill"></use></svg>
                      Dark
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                  <li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center active" data-bs-theme-value="auto" aria-pressed="true">
                      <svg class="bi me-2 theme-icon"><use href="#circle-half"></use></svg>
                      Auto
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                </ul>
</li>
            </div>
          </div>
          <div class="row mobile-row">
            <div class="col">
              <div class="sidenav-view-selector">
                <div class="accordion accordion-flush" id="accordionFlush9">
                  <div class="accordion-item">
                    <h2 class="accordion-header" id="flush-headingNine">
                      <button class="accordion-button collapsed" id="instructor" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseNine" aria-expanded="false" aria-controls="flush-collapseNine">
                        <i id="eye" aria-hidden="true" class="icon" data-feather="eye"></i> Instructor View
                      </button>
                    </h2>
                    <div id="flush-collapseNine" class="accordion-collapse collapse" aria-labelledby="flush-headingNine" data-bs-parent="#accordionFlush2">
                      <div class="accordion-body">
                        <a href="../aio.html">Learner View</a>
                      </div>
                    </div>
                  </div>
<!--/div.accordion-item-->
                </div>
<!--/div.accordion-flush-->
              </div>
<!--div.sidenav-view-selector -->
            </div>
<!--/div.col -->

            <hr>
</div>
<!--/div.mobile-row -->

          <div class="accordion accordion-flush" id="accordionFlush11">
            <div class="accordion-item">

              <button id="chapters" class="accordion-button show" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseEleven" aria-expanded="false" aria-controls="flush-collapseEleven">
                <h2 class="accordion-header chapters" id="flush-headingEleven">
                  EPISODES
                </h2>
              </button>
              <div id="flush-collapseEleven" class="accordion-collapse show collapse" aria-labelledby="flush-headingEleven" data-bs-parent="#accordionFlush11">

                <div class="accordion-body">
                  <div class="accordion accordion-flush" id="accordionFlush1">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading1">
        <a href="index.html">Summary and Schedule</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush2">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading2">
        <a href="01-intro.html">1. Introduction to Chapel</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush3">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading3">
        <a href="02-variables.html">2. Basic syntax and variables</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush4">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading4">
        <a href="03-ranges-arrays.html">3. Ranges and arrays</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush5">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading5">
        <a href="04-conditionals.html">4. Conditional statements</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush6">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading6">
        <a href="05-loops.html">5. Getting started with loops</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush7">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading7">
        <a href="06-procedures.html">6. Procedures</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush8">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading8">
        <a href="07-commandargs.html">7. Using command-line arguments</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush9">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading9">
        <a href="08-timing.html">8. Measuring code performance</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush10">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading10">
        <a href="11-parallel-intro.html">9. Intro to parallel computing</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush11">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading11">
        <a href="12-fire-forget-tasks.html">10. Fire-and-forget tasks</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush12">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading12">
        <a href="13-synchronization.html">11. Synchronising tasks</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush13">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading13">
        <a href="14-parallel-case-study.html">12. Task parallelism with Chapel</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush14">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading14">
        <a href="21-locales.html">13. Running code on multiple machines</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush15">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading15">
        <a href="22-domains.html">14. Domains and data parallelism</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

                </div>
              </div>
            </div>

            <hr class="half-width">
<div class="accordion accordion-flush lesson-resources" id="accordionFlush12">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-headingTwelve">
                  <button class="accordion-button collapsed" id="lesson-resources" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseTwelve" aria-expanded="false" aria-controls="flush-collapseTwelve">
                    RESOURCES
                  </button>
                </h2>
                <div id="flush-collapseTwelve" class="accordion-collapse collapse" aria-labelledby="flush-headingTwelve" data-bs-parent="#accordionFlush12">
                  <div class="accordion-body">
                    <ul>
<li>
                        <a href="../instructor/key-points.html">Key Points</a>
                      </li>
                      <li>
                        <a href="../instructor/instructor-notes.html">Instructor Notes</a>
                      </li>
                      <li>
                        <a href="../instructor/images.html">Extract All Images</a>
                      </li>
                      <hr>
<li><a class="dropdown-item" href="reference.html">Reference</a></li>
                    </ul>
</div>
                </div>
              </div>
            </div>
            <hr class="half-width lesson-resources">
<a href="../instructor/aio.html">See all in one page</a>


            <hr class="d-none d-sm-block d-md-none">
<div class="d-grid gap-1">

            </div>
          </div>
<!-- /div.accordion -->
        </div>
<!-- /div.sidebar-inner -->
      </nav>
</div>
<!-- /div.sidebar -->
  </div>
<!-- /div.sidebar-col -->
<!-- END:   inst/pkgdown/templates/navbar.html-->

        <!-- START: inst/pkgdown/templates/content-extra.html -->
  <div class="col-xl-8 col-lg-12 primary-content">
    <main id="main-content" class="main-content"><div class="container lesson-content">
        
        
<section id="aio-01-intro"><p>Content from <a href="01-intro.html">Introduction to Chapel</a></p>
<hr>
<p>Last updated on 2024-10-08 |

        <a href="https://github.com/hpc-carpentry/hpc-chapel/edit/main/episodes/01-intro.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 30 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>“What is Chapel and why is it useful?”</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>“Write and execute our first Chapel program.”</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<p><strong><em>Chapel</em></strong> is a modern, open-source programming
language that supports HPC via high-level abstractions for data
parallelism and task parallelism. These abstractions allow the users to
express parallel codes in a natural, almost intuitive, manner. In
contrast with other high-level parallel languages, however, Chapel was
designed around a <em>multi-resolution</em> philosophy. This means that
users can incrementally add more detail to their original code
prototype, to optimise it to a particular computer as closely as
required.</p>
<p>In a nutshell, with Chapel we can write parallel code with the
simplicity and readability of scripting languages such as Python or
MATLAB, but achieving performance comparable to compiled languages like
C or Fortran (+ traditional parallel libraries such as MPI or
OpenMP).</p>
<p>In this lesson we will learn the basic elements and syntax of the
language; then we will study <strong><em>task parallelism</em></strong>,
the first level of parallelism in Chapel, and finally we will use
parallel data structures and <strong><em>data parallelism</em></strong>,
which is the higher level of abstraction, in parallel programming,
offered by Chapel.</p>
<section><h2 class="section-heading" id="getting-started">Getting started<a class="anchor" aria-label="anchor" href="#getting-started"></a>
</h2>
<hr class="half-width">
<p>Chapel is a compilable language which means that we must
<strong><em>compile</em></strong> our <strong><em>source
code</em></strong> to generate a <strong><em>binary</em></strong> or
<strong><em>executable</em></strong> that we can then run in the
computer.</p>
<p>Chapel source code must be written in text files with the extension
<strong><em>.chpl</em></strong>. Let’s write a simple “hello world”-type
program to demonstrate how we write Chapel code! Using your favourite
text editor, create the file <code>hello.chpl</code> with the following
content:</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="ex">writeln</span><span class="er">(</span><span class="st">'If we can see this, everything works!'</span><span class="kw">);</span></span></code></pre>
</div>
<p>This program can then be compiled with the following bash
command:</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="ex">chpl</span> <span class="at">--fast</span> hello.chpl</span></code></pre>
</div>
<p>The flag <code>--fast</code> indicates the compiler to optimise the
binary to run as fast as possible in the given architecture. The
<code>-o</code> option tells Chapel what to call the final output
program, in this case <code>hello.o</code>.</p>
<p>To run the code, you execute it as you would any other program:</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="ex">./hello.o</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>If we can see this, everything works!</code></pre>
</div>
</section><section><h2 class="section-heading" id="running-on-a-cluster">Running on a cluster<a class="anchor" aria-label="anchor" href="#running-on-a-cluster"></a>
</h2>
<hr class="half-width">
<p>Depending on the code, it might utilise several or even all cores on
the current node. The command above implies that you are allowed to
utilise all cores. This might not be the case on an HPC cluster, where a
login node is shared by many people at the same time, and where it might
not be a good idea to occupy all cores on a login node with
CPU-intensive tasks. Instead, you will need to submit your Chapel run as
a job to the scheduler asking for a specific number of CPU cores.</p>
<p>Use <code>module avail chapel</code> to list Chapel packages on your
HPC cluster, and select the best fit for Chapel, e.g. the single-locale
Chapel module:</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="ex">module</span> load chapel-multicore</span></code></pre>
</div>
<p>Then, for running a test code on a cluster you would submit an
interactive job to the queue</p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="ex">salloc</span> <span class="at">--time</span><span class="op">=</span>0:30:0 <span class="at">--ntasks</span><span class="op">=</span>1 <span class="at">--cpus-per-task</span><span class="op">=</span>3 <span class="at">--mem-per-cpu</span><span class="op">=</span>1000 <span class="at">--account</span><span class="op">=</span>def-guest</span></code></pre>
</div>
<p>and then inside that job compile and run the test code</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="ex">chpl</span> <span class="at">--fast</span> hello.chpl</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="ex">./hello.o</span></span></code></pre>
</div>
<p>For production jobs, you would compile the code and then submit a
batch script to the queue:</p>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="ex">chpl</span> <span class="at">--fast</span> hello.chpl</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a><span class="ex">sbatch</span> script.sh</span></code></pre>
</div>
<p>where the script <code>script.sh</code> would set all Slurm variables
and call the executable <code>mybinary</code>.</p>
</section><section><h2 class="section-heading" id="case-study">Case study<a class="anchor" aria-label="anchor" href="#case-study"></a>
</h2>
<hr class="half-width">
<p>Along all the Chapel lessons we will be using the following <em>case
study</em> as the leading thread of the discussion. Essentially, we will
be building, step by step, a Chapel code to solve the <strong><em>Heat
transfer</em></strong> problem described below. Then we will parallelize
the code to improve its performance.</p>
<p>Suppose that we have a square metallic plate with some initial heat
distribution or <strong><em>initial conditions</em></strong>. We want to
simulate the evolution of the temperature across the plate when its
border is in contact with a different heat distribution that we call the
<strong><em>boundary conditions</em></strong>.</p>
<p>The Laplace equation is the mathematical model for the evolution of
the temperature in the plate. To solve this equation numerically, we
need to <strong><em>discretise</em></strong> it, i.e. to consider the
plate as a grid, or matrix of points, and to evaluate the temperature on
each point at each iteration, according to the following
<strong><em>difference equation</em></strong>:</p>
<pre class="chpl"><code><span><span class="va">temp_new</span><span class="op">[</span><span class="va">i</span>,<span class="va">j</span><span class="op">]</span> <span class="op">=</span> <span class="fl">0.25</span> <span class="op">*</span> <span class="op">(</span><span class="va">temp</span><span class="op">[</span><span class="va">i</span><span class="op">-</span><span class="fl">1</span>,<span class="va">j</span><span class="op">]</span> <span class="op">+</span> <span class="va">temp</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span>,<span class="va">j</span><span class="op">]</span> <span class="op">+</span> <span class="va">temp</span><span class="op">[</span><span class="va">i</span>,<span class="va">j</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span> <span class="op">+</span> <span class="va">temp</span><span class="op">[</span><span class="va">i</span>,<span class="va">j</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span></span></code></pre>
<p>Here <code>temp_new</code> stands for the new temperature at the
current iteration, while <code>temp</code> contains the temperature
calculated at the past iteration (or the initial conditions in case we
are at the first iteration). The indices <code>i</code> and
<code>j</code> indicate that we are working on the point of the grid
located at the <em>i</em>th row and the <em>j</em>th column.</p>
<p>So, our objective is to:</p>
<blockquote>
<h2 id="goals">Goals</h2>
<ol style="list-style-type: decimal">
<li>
<p>Write a code to implement the difference equation above. The code
should have the following requirements:</p>
<ul>
<li>It should work for any given number of rows and columns in the
grid.</li>
<li>It should run for a given number of iterations, or until the
difference between <code>temp_new</code> and <code>temp</code> is
smaller than a given tolerance value.</li>
<li>It should output the temperature at a desired position on the grid
every given number of iterations.</li>
</ul>
</li>
<li><p>Use task parallelism to improve the performance of the code and
run it in the cluster</p></li>
<li><p>Use data parallelism to improve the performance of the code and
run it in the cluster.</p></li>
</ol>
</blockquote>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>“Chapel is a compiled language - any programs we make must be
compiled with <code>chpl</code>.”</li>
<li>“The <code>--fast</code> flag instructs the Chapel compiler to
optimise our code.”</li>
<li>“The <code>-o</code> flag tells the compiler what to name our output
(otherwise it gets named <code>a.out</code>)”</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-02-variables"><p>Content from <a href="02-variables.html">Basic syntax and variables</a></p>
<hr>
<p>Last updated on 2024-10-08 |

        <a href="https://github.com/hpc-carpentry/hpc-chapel/edit/main/episodes/02-variables.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 30 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>“How do I write basic Chapel code?”</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>“Perform basic maths in Chapel.”</li>
<li>“Understand Chapel’s basic data types.”</li>
<li>“Understand how to read and fix errors.”</li>
<li>“Know how to define and use data stored as variables.”</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<p>Using basic maths in Chapel is fairly intuitive. Try compiling the
following code to see how the different mathematical operators work.</p>
<pre class="chpl"><code>writeln(4 + 5);
writeln(4 - 5);
writeln(4 * 5);
writeln(4 / 5);   // integer division
writeln(4.0 / 5.0); // floating-point division
writeln(4 ** 5);  // exponentiation</code></pre>
<p>In this example, our code is called <code>operators.chpl</code>. You
can compile it with the following commands:</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="ex">chpl</span> operators.chpl <span class="at">--fast</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="ex">./operators.o</span></span></code></pre>
</div>
<p>You should see output that looks something like the following:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code><span><span class="fl">9</span></span>
<span><span class="op">-</span><span class="fl">1</span></span>
<span><span class="fl">20</span></span>
<span><span class="fl">0</span></span>
<span><span class="fl">0.8</span></span>
<span><span class="fl">1024</span></span></code></pre>
</div>
<p>Code beginning with <code>//</code> is interpreted as a comment — it
does not get run. Comments are very valuable when writing code, because
they allow us to write notes to ourselves about what each piece of code
does. You can also create block comments with <code>/*</code> and
<code>*/</code>:</p>
<pre class="chpl"><code>/* This is a block comment.
It can span as many lines as you want!
(like this) */</code></pre>
<section><h2 class="section-heading" id="variables">Variables<a class="anchor" aria-label="anchor" href="#variables"></a>
</h2>
<hr class="half-width">
<p>Granted, we probably want to do more than basic maths with Chapel. We
will need to store the results of complex operations using variables.
Variables in programming are not the same as the mathematical concept.
In programming, a variable represents (or references) a location in the
memory of the computer where we can store information or data while
executing a program. A variable has three elements:</p>
<ol style="list-style-type: decimal">
<li>a <strong><em>name</em></strong> or label, to identify the
variable</li>
<li>a <strong><em>type</em></strong>, that indicates the kind of data
that we can store in it, and</li>
<li>a <strong><em>value</em></strong>, the actual information or data
stored in the variable.</li>
</ol>
<p>Variables in Chapel are declared with the <code>var</code> or
<code>const</code> keywords. When a variable declared as
<code>const</code> is initialised, its value cannot be modified anymore
during the execution of the program. What happens if we try to modify a
constant variable like <code>test</code> below?</p>
<pre class="chpl"><code>const test = 100;
test = 200;
writeln('The value of test is: ', test);
writeln(test / 4);</code></pre>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="ex">chpl</span> variables.chpl</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">ERROR<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="error" tabindex="0"><code>variables.chpl:2: error: cannot assign to const variable</code></pre>
</div>
<p>The compiler threw an error, and did not compile our program. This is
a feature of compiled languages - if there is something wrong, we will
typically see an error at compile-time, instead of while running it.
Although we already kind of know why the error was caused (we tried to
reassign the value of a <code>const</code> variable, which by definition
cannot be changed), let’s walk through the error as an example of how to
troubleshoot our programs.</p>
<ul>
<li><p><code>variables.chpl:2:</code> indicates that the error was
caused on line 2 of our <code>variables.chpl</code> file.</p></li>
<li><p><code>error:</code> indicates that the issue was an error, and
blocks compilation. Sometimes the compiler will just give us warning or
information, not necessarily errors. When we see something that is not
an error, we should carefully read the output and consider if it
necessitates changing our code. Errors must be fixed, as they will block
the code from compiling.</p></li>
<li><p><code>cannot assign to const variable</code> indicates that we
were trying to reassign a <code>const</code> variable, which is
explicitly not allowed in Chapel.</p></li>
</ul>
<p>To fix this error, we can change <code>const</code> to
<code>var</code> when declaring our <code>test</code> variable.
<code>var</code> indicates a variable that can be reassigned.</p>
<pre class="chpl"><code>var test = 100;
test = 200;
writeln('The value of test is: ', test);
writeln(test / 4);</code></pre>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="ex">chpl</span> variables.chpl</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>The value of test is: 200
50</code></pre>
</div>
<p>In Chapel, to initialize a variable we must specify the type of the
variable, or initialise it in place with some value. The common variable
types in Chapel are:</p>
<ul>
<li>integer <code>int</code> (positive or negative whole numbers)</li>
<li>floating-point number <code>real</code> (decimal values)</li>
<li>Boolean <code>bool</code> (true or false)</li>
<li>string <code>string</code> (any type of text)</li>
</ul>
<p>These two variables below are initialized with the type. If no
initial value is given, Chapel will initialise a variable with a default
value depending on the declared type, for example 0 for integers and 0.0
for real variables.</p>
<pre class="chpl"><code>var counter: int;
var delta: real;
writeln("counter is ", counter, " and delta is ", delta);</code></pre>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="ex">chpl</span> variables.chpl</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a><span class="ex">./variables.o</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>counter is 0 and delta is 0.0</code></pre>
</div>
<p>If a variable is initialised with a value but without a type, Chapel
will infer its type from the given initial value:</p>
<pre class="chpl"><code>const test = 100;
writeln('The value of test is ', test, ' and its type is ', test.type:string);</code></pre>
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="ex">chpl</span> variables.chpl</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a><span class="ex">./variables.o</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>The value of test is 100 and its type is int(64)</code></pre>
</div>
<p>When initialising a variable, we can also assign its type in addition
to its value:</p>
<pre class="chpl"><code>const tolerance: real = 0.0001;
const outputFrequency: int = 20;</code></pre>
<div id="callout1" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Callout</h3>
<div class="callout-content">
<p>Note that these two notations below are different, but produce the
same result in the end:</p>
<pre class="chpl"><code>var a: real = 10.0;   // we specify both the type and the value
var a = 10: real;     // we specify only the value (10 converted to real)</code></pre>
</div>
</div>
</div>
<div id="callout2" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Callout</h3>
<div class="callout-content">
<p>In the following code (saved as <code>variables.chpl</code>) we have
not initialised the variable <code>test</code> before trying to use it
in line 2:</p>
<pre class="chpl"><code>const test;  // declare 'test' variable
writeln('The value of test is: ', test);</code></pre>
<div class="codewrapper">
<h3 class="code-label">ERROR<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="error" tabindex="0"><code>variables.chpl:1: error: 'test' is not initialized and has no type
variables.chpl:1: note: cannot find initialization point to split-init this variable
variables.chpl:2: note: 'test' is used here before it is initialized</code></pre>
</div>
</div>
</div>
</div>
<p>Now we know how to set, use, and change a variable, as well as the
implications of using <code>var</code> and <code>const</code>. We also
know how to read and interpret errors.</p>
<p>Let’s practice defining variables and use this as the starting point
of our simulation code. The code will be stored in the file
<code>base_solution.chpl</code>. We will be solving the heat transfer
problem introduced in the previous section, starting with some initial
temperature and computing a new temperature at each iteration. We will
then compute the greatest difference between the old and the new
temperature and will check if it is smaller than a preset
<code>tolerance</code>. If no, we will continue iterating. If yes, we
will stop iterations and will print the final temperature. We will also
stop iterations if we reach the maximum number of iterations
<code>niter</code>.</p>
<p>Our grid will be of size <code>rows</code> by <code>cols</code>, and
every <code>outputFrequency</code>th iteration we will print temperature
at coordinates <code>x</code> and <code>y</code>.</p>
<p>The variable <code>delta</code> will store the greatest difference in
temperature from one iteration to another. The variable <code>tmp</code>
will store some temporary results when computing the temperatures.</p>
<p>Let’s define our variables:</p>
<pre class="chpl"><code>const rows = 100;               // number of rows in the grid
const cols = 100;               // number of columns in the grid
const niter = 500;              // maximum number of iterations
const x = 50;                   // row number for a printout
const y = 50;                   // column number for a printout
var delta: real;                // greatest difference in temperature from one iteration to another
var tmp: real;                  // for temporary results
const tolerance: real = 0.0001; // smallest difference in temperature that would be accepted before stopping
const outputFrequency: int = 20;   // the temperature will be printed every outputFrequency iterations</code></pre>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>“A comment is preceded with <code>//</code> or surrounded by
<code>/* and</code>*/`”</li>
<li>“All variables in Chapel have a type, whether assigned explicitly by
the user, or chosen by the Chapel compiler based on its value.”</li>
<li>“Reassigning a new value to a <code>const</code> variable will
produce an error during compilation. If you want to assign a new value
to a variable, declare that variable with the <code>var</code>
keyword.”</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-03-ranges-arrays"><p>Content from <a href="03-ranges-arrays.html">Ranges and arrays</a></p>
<hr>
<p>Last updated on 2024-10-08 |

        <a href="https://github.com/hpc-carpentry/hpc-chapel/edit/main/episodes/03-ranges-arrays.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 90 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>“What is Chapel and why is it useful?”</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>“Learn to define and use ranges and arrays.”</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="ranges-and-arrays">Ranges and Arrays<a class="anchor" aria-label="anchor" href="#ranges-and-arrays"></a>
</h2>
<hr class="half-width">
<p>A series of integers (1,2,3,4,5, for example), is called a
<strong><em>range</em></strong>. Ranges are generated with the
<code>..</code> operator. Let’s examine what a range looks like; we
store the following code as <code>ranges.chpl</code>. Here we introduce
a very simple loop, cycling through all elements of the range and
printing their values (we will study <code>for</code> loops in a
separate section):</p>
<pre class="chpl"><code>var example_range = 0..10;
writeln('Our example range was set to: ', example_range);
for x in example_range do writeln(x);</code></pre>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="ex">chpl</span> ranges.chpl</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="ex">./ranges.o</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Our example range was set to: 0..10
0
1
...
9
10</code></pre>
</div>
<p>Among other uses, ranges can be used to declare
<strong><em>arrays</em></strong> of variables. An array is a
multidimensional collection of values of the same type. Arrays can be of
any size. Let’s define a 1-dimensional array of the size
<code>example_range</code> and see what it looks like. Notice how the
size of an array is included with its type.</p>
<pre class="chpl"><code>var example_range = 0..10;
writeln('Our example range was set to: ', example_range);
var example_array: [example_range] real;
writeln('Our example array is now: ', example_array);</code></pre>
<p>We can reassign the values in our example array the same way we would
reassign a variable. An array can either be set all to a single value,
or to a sequence of values.</p>
<pre class="chpl"><code>var example_range = 0..10;
writeln('Our example range was set to: ', example_range);
var example_array: [example_range] real;
writeln('Our example array is now: ', example_array);
example_array = 5;
writeln('When set to 5: ', example_array);
example_array = 1..11;
writeln('When set to a range: ', example_array);</code></pre>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="ex">chpl</span> ranges.chpl</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a><span class="ex">./ranges.o</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Our example range was set to: 0..10
Our example array is now: 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0
When set to 5: 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0
When set to a range: 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 10.0 11.0</code></pre>
</div>
<p>Notice how ranges are “right inclusive”, the last number of a range
is included in the range. This is different from languages like Python
where this does not happen.</p>
</section><section><h2 class="section-heading" id="indexing-elements">Indexing elements<a class="anchor" aria-label="anchor" href="#indexing-elements"></a>
</h2>
<hr class="half-width">
<p>We can retrieve and reset specific values of an array using
<code>[]</code> notation. Note that we use the same square bracket
notation in two different contexts: (1) to declare an array, with the
square brackets containing the array’s full index range
<code>[example_range]</code>, and (2) to access specific array elements,
as we will see below. Let’s try retrieving and setting a specific value
in our example so far:</p>
<pre class="chpl"><code>var example_range = 0..10;
writeln('Our example range was set to: ', example_range);
var example_array: [example_range] real;
writeln('Our example array is now: ', example_array);
example_array = 5;
writeln('When set to 5: ', example_array);
example_array = 1..11;
writeln('When set to a range: ', example_array);
// retrieve the 5th index
writeln(example_array[5]);
// set index 5 to a new value
example_array[5] = 99999;
writeln(example_array);</code></pre>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="ex">chpl</span> ranges.chpl</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a><span class="ex">./ranges.o</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Our example range was set to: 0..10
Our example array is now: 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0
When set to 5: 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0
When set to a range: 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 10.0 11.0
6.0
1.0 2.0 3.0 4.0 5.0 99999.0 7.0 8.0 9.0 10.0 11.0</code></pre>
</div>
<p>One very important thing to note - in this case, index 5 was actually
the 6th element. This was caused by how we set up our array. When we
defined our array using a range starting at 0, element 5 corresponds to
the 6th element. Unlike most other programming languages, arrays in
Chapel do not start at a fixed value - they can start at any number
depending on how we define them! For instance, let’s redefine
example_range to start at 5:</p>
<pre class="chpl"><code>var example_range = 5..15;
writeln('Our example range was set to: ', example_range);
var example_array: [example_range] real;
writeln('Our example array is now: ', example_array);
example_array = 5;
writeln('When set to 5: ', example_array);
example_array = 1..11;
writeln('When set to a range: ', example_array);
// retrieve the 5th index
writeln(example_array[5]);
// set index 5 to a new value
example_array[5] = 99999;
writeln(example_array);</code></pre>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="ex">chpl</span> ranges.chpl</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a><span class="ex">./ranges.o</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Our example range was set to: 5..15
Our example array is now: 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0
When set to 5: 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0
When set to a range: 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 10.0 11.0
1.0
99999.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 10.0 11.0</code></pre>
</div>
</section><section><h2 class="section-heading" id="back-to-our-simulation">Back to our simulation<a class="anchor" aria-label="anchor" href="#back-to-our-simulation"></a>
</h2>
<hr class="half-width">
<p>Let’s define a two-dimensional array for use in our simulation and
set its initial values:</p>
<pre class="chpl"><code>// this is our "plate"
var temp: [0..rows+1, 0..cols+1] real;
temp[1..rows,1..cols] = 25;     // set the initial temperature on the internal grid</code></pre>
<p>This is a matrix (2D array) with (<code>rows + 2</code>) rows and
(<code>cols + 2</code>) columns of real numbers. The ranges
<code>0..rows+1</code> and <code>0..cols+1</code> used here, not only
define the size and shape of the array, they stand for the indices with
which we could access particular elements of the array using the
<code>[ , ]</code> notation. For example, <code>temp[0,0]</code> is the
real variable located at the first row and first column of the array
<code>temp</code>, while <code>temp[3,7]</code> is the one at the 4th
row and 8th column; <code>temp[2,3..15]</code> access columns 4th to
16th of the 3th row of <code>temp</code>, and <code>temp[0..3,4]</code>
corresponds to the first 4 rows on the 5th column of
<code>temp</code>.</p>
<p>We divide our “plate” into two parts: (1) the internal grid
<code>1..rows,1..cols</code> on which we set the initial temperature at
25.0, and (2) the surrounding layer of <em>ghost points</em> with row
indices equal to <code>0</code> or <code>rows+1</code> and column
indices equal to <code>0</code> or <code>cols+1</code>. The temperature
in the ghost layer is equal to 0.0 by default, as we do not assign a
value there.</p>
<p>We must now be ready to start coding our simulations. Let’s print
some information about the initial configuration, compile the code, and
execute it to see if everything is working as expected.</p>
<pre class="chpl"><code>const rows = 100;
const cols = 100;
const niter = 500;
const x = 50;                   // row number of the desired position
const y = 50;                   // column number of the desired position
const tolerance = 0.0001;       // smallest difference in temperature that would be accepted before stopping
const outputFrequency: int = 20;   // the temperature will be printed every outputFrequency iterations

// this is our "plate"
var temp: [0..rows+1, 0..cols+1] real;
temp[1..rows,1..cols] = 25;     // set the initial temperature on the internal grid

writeln('This simulation will consider a matrix of ', rows, ' by ', cols, ' elements.');
writeln('Temperature at start is: ', temp[x, y]);</code></pre>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="ex">chpl</span> base_solution.chpl</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a><span class="ex">./base_solution</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>This simulation will consider a matrix of 100 by 100 elements.
Temperature at start is: 25.0</code></pre>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>“A range is a sequence of integers.”</li>
<li>“An array holds a non-negative number of values of the same
type.”</li>
<li>“Chapel arrays can start at any index, not just 0 or 1.”</li>
<li>“You can index arrays with the <code>[]</code> brackets.”</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-04-conditionals"><p>Content from <a href="04-conditionals.html">Conditional statements</a></p>
<hr>
<p>Last updated on 2024-10-08 |

        <a href="https://github.com/hpc-carpentry/hpc-chapel/edit/main/episodes/04-conditionals.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 90 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>“How do I add conditional logic to my code?”</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>“You can use the <code>==</code>, <code>&gt;</code>,
<code>&gt;=</code>, etc. operators to make a comparison that returns
true or false.”</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<p>Chapel, as most <em>high level programming languages</em>, has
different statements to control the flow of the program or code. The
conditional statements are: the <strong><em>if statement</em></strong>,
and the <strong><em>while statement</em></strong>. These statements both
rely on comparisons between values. Let’s try a few comparisons to see
how they work (<code>conditionals.chpl</code>):</p>
<pre class="chpl"><code><span><span class="fu">writeln</span><span class="op">(</span><span class="fl">1</span> <span class="op">==</span> <span class="fl">2</span><span class="op">)</span>;</span>
<span><span class="fu">writeln</span><span class="op">(</span><span class="fl">1</span> <span class="op">!=</span> <span class="fl">2</span><span class="op">)</span>;</span>
<span><span class="fu">writeln</span><span class="op">(</span><span class="fl">1</span> <span class="op">&gt;</span> <span class="fl">2</span><span class="op">)</span>;</span>
<span><span class="fu">writeln</span><span class="op">(</span><span class="fl">1</span> <span class="op">&gt;=</span> <span class="fl">2</span><span class="op">)</span>;</span>
<span><span class="fu">writeln</span><span class="op">(</span><span class="fl">1</span> <span class="op">&lt;</span> <span class="fl">2</span><span class="op">)</span>;</span>
<span><span class="fu">writeln</span><span class="op">(</span><span class="fl">1</span> <span class="op">&lt;=</span> <span class="fl">2</span><span class="op">)</span>;</span></code></pre>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="ex">chpl</span> conditionals.chpl</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="ex">./conditionals.o</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code><span><span class="va">false</span></span>
<span><span class="va">true</span></span>
<span><span class="va">false</span></span>
<span><span class="va">false</span></span>
<span><span class="va">true</span></span>
<span><span class="va">true</span></span></code></pre>
</div>
<p>You can combine comparisons with the <code>&amp;&amp;</code> (AND)
and <code>||</code> (OR) operators. <code>&amp;&amp;</code> only returns
<code>true</code> if both conditions are true, while <code>||</code>
returns <code>true</code> if either condition is true.</p>
<pre class="chpl"><code><span><span class="fu">writeln</span><span class="op">(</span><span class="fl">1</span> <span class="op">==</span> <span class="fl">2</span><span class="op">)</span>;</span>
<span><span class="fu">writeln</span><span class="op">(</span><span class="fl">1</span> <span class="op">!=</span> <span class="fl">2</span><span class="op">)</span>;</span>
<span><span class="fu">writeln</span><span class="op">(</span><span class="fl">1</span> <span class="op">&gt;</span> <span class="fl">2</span><span class="op">)</span>;</span>
<span><span class="fu">writeln</span><span class="op">(</span><span class="fl">1</span> <span class="op">&gt;=</span> <span class="fl">2</span><span class="op">)</span>;</span>
<span><span class="fu">writeln</span><span class="op">(</span><span class="fl">1</span> <span class="op">&lt;</span> <span class="fl">2</span><span class="op">)</span>;</span>
<span><span class="fu">writeln</span><span class="op">(</span><span class="fl">1</span> <span class="op">&lt;=</span> <span class="fl">2</span><span class="op">)</span>;</span>
<span><span class="fu">writeln</span><span class="op">(</span><span class="va">true</span> <span class="op">&amp;&amp;</span> <span class="va">true</span><span class="op">)</span>;</span>
<span><span class="fu">writeln</span><span class="op">(</span><span class="va">true</span> <span class="op">&amp;&amp;</span> <span class="va">false</span><span class="op">)</span>;</span>
<span><span class="fu">writeln</span><span class="op">(</span><span class="va">true</span> <span class="op">||</span> <span class="va">false</span><span class="op">)</span>;</span></code></pre>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="ex">chpl</span> conditionals.chpl</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a><span class="ex">./conditionals.o</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code><span><span class="va">false</span></span>
<span><span class="va">true</span></span>
<span><span class="va">false</span></span>
<span><span class="va">false</span></span>
<span><span class="va">true</span></span>
<span><span class="va">true</span></span>
<span><span class="va">true</span></span>
<span><span class="va">false</span></span>
<span><span class="va">true</span></span></code></pre>
</div>
<section><h2 class="section-heading" id="control-flow">Control flow<a class="anchor" aria-label="anchor" href="#control-flow"></a>
</h2>
<hr class="half-width">
<p>The general syntax of a while statement is:</p>
<pre class="chpl"><code>while condition do
{instructions}</code></pre>
<p>The code flows as follows: first, the condition is evaluated, and
then, if it is satisfied, all the instructions within the curly brackets
are executed one by one. This will be repeated over and over again until
the condition does not hold anymore.</p>
<p>The main loop in our simulation can be programmed using a while
statement like this</p>
<pre class="chpl"><code>//this is the main loop of the simulation
var c = 0;
delta = tolerance;
while (c &lt; niter &amp;&amp; delta &gt;= tolerance) do
{
  c += 1;
  // actual simulation calculations will go here
}</code></pre>
<p>Essentially, what we want is to repeat all the code inside the curly
brackets until the number of iterations is greater than or equal to
<code>niter</code>, or the difference of temperature between iterations
is less than <code>tolerance</code>. (Note that in our case, as
<code>delta</code> was not initialised when declared – and thus Chapel
assigned it the default real value 0.0 – we need to assign it a value
greater than or equal to 0.001, or otherwise the condition of the while
statement will never be satisfied. A good starting point is to simple
say that <code>delta</code> is equal to <code>tolerance</code>).</p>
<p>To count iterations we just need to keep adding 1 to the counter
variable <code>c</code>. We could do this with <code>c=c+1</code>, or
with the compound assignment, <code>+=</code>, as in the code above. To
program the rest of the logic inside the curly brackets, on the other
hand, we will need more elaborated instructions.</p>
<p>Let’s focus, first, on printing the temperature every
<code>outputFrequency = 20</code> iterations. To achieve this, we only
need to check whether <code>c</code> is a multiple of
<code>outputFrequency</code>, and in that case, to print the temperature
at the desired position. This is the type of control that an
<strong><em>if statement</em></strong> give us. The general syntax
is:</p>
<pre class="chpl"><code>if condition then
{instructions A}
else
{instructions B}</code></pre>
<p>The set of instructions A is executed once if the condition is
satisfied; the set of instructions B is executed otherwise (the else
part of the if statement is optional).</p>
<p>So, in our case this would do the trick:</p>
<pre class="chpl"><code>if (c % outputFrequency == 0)
{
  writeln('Temperature at iteration ', c, ': ', temp[x, y]);
}</code></pre>
<p>Note that when only one instruction will be executed, there is no
need to use the curly brackets. <code>%</code> is the modulo operator,
it returns the remainder after the division (i.e. it returns zero when
<code>c</code> is multiple of <code>outputFrequency</code>).</p>
<p>Let’s compile and execute our code to see what we get until now</p>
<pre class="chpl"><code>const rows = 100;
const cols = 100;
const niter = 500;
const x = 50;                   // row number of the desired position
const y = 50;                   // column number of the desired position
const tolerance = 0.0001;       // smallest difference in temperature that
                                // would be accepted before stopping
const outputFrequency: int = 20;   // the temperature will be printed every outputFrequency iterations

// this is our "plate"
var temp: [0..rows+1, 0..cols+1] real = 25;

writeln('This simulation will consider a matrix of ', rows, ' by ', cols, ' elements.');
writeln('Temperature at start is: ', temp[x, y]);

//this is the main loop of the simulation
var c = 0;
delta = tolerance;
while (c &lt; niter &amp;&amp; delta &gt;= tolerance) do
{
  c += 1;
  if (c % outputFrequency == 0)
  {
    writeln('Temperature at iteration ', c, ': ', temp[x, y]);
  }
}</code></pre>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="ex">chpl</span> base_solution.chpl</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a><span class="ex">./base_solution.o</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>This simulation will consider a matrix of 100 by 100 elements.
Temperature at start is: 25.0
Temperature at iteration 20: 25.0
Temperature at iteration 40: 25.0
Temperature at iteration 60: 25.0
Temperature at iteration 80: 25.0
Temperature at iteration 100: 25.0
Temperature at iteration 120: 25.0
Temperature at iteration 140: 25.0
Temperature at iteration 160: 25.0
Temperature at iteration 180: 25.0
Temperature at iteration 200: 25.0
Temperature at iteration 220: 25.0
Temperature at iteration 240: 25.0
Temperature at iteration 260: 25.0
Temperature at iteration 280: 25.0
Temperature at iteration 300: 25.0
Temperature at iteration 320: 25.0
Temperature at iteration 340: 25.0
Temperature at iteration 360: 25.0
Temperature at iteration 380: 25.0
Temperature at iteration 400: 25.0
Temperature at iteration 420: 25.0
Temperature at iteration 440: 25.0
Temperature at iteration 460: 25.0
Temperature at iteration 480: 25.0
Temperature at iteration 500: 25.0</code></pre>
</div>
<p>Of course the temperature is always 25.0 at any iteration other than
the initial one, as we haven’t done any computation yet.</p>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>“Use
<code>if &lt;condition&gt; then {instructions A} else {instructions B}</code>
syntax to execute one set of instructions if the condition is satisfied,
and the other set of instructions if the condition is not
satisfied.”</li>
<li>This syntax can be simplified to
<code>if &lt;condition&gt; then {instructions}</code> if we only want to
execute the instructions within the curly brackets if the condition is
satisfied.</li>
<li>“Use <code>while &lt;condition&gt; do {instructions}</code> to
repeatedly execute the instructions within the curly brackets while the
condition is satisfied. The instructions will be executed over and over
again until the condition does not hold anymore.”</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-05-loops"><p>Content from <a href="05-loops.html">Getting started with loops</a></p>
<hr>
<p>Last updated on 2024-10-08 |

        <a href="https://github.com/hpc-carpentry/hpc-chapel/edit/main/episodes/05-loops.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 90 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>“How do I run the same piece of code repeatedly?”</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>“Learn to use <code>for</code> loops to run over every element of an
iterand.”</li>
<li>“Learn the difference between using <code>for</code> loops and using
a <code>while</code> statement to repeatedly execute a code block.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<p>To compute the new temperature, i.e. each element of
<code>temp_new</code>, we need to add all the surrounding elements in
<code>temp</code> and divide the result by 4. And, essentially, we need
to repeat this process for all the elements of <code>temp_new</code>,
or, in other words, we need to <em>iterate</em> over the elements of
<code>temp_new</code>. When it comes to iterating over a given number of
elements, the <strong><em>for-loop</em></strong> is what we want to use.
The for-loop has the following general syntax:</p>
<pre class="chpl"><code>for index in iterand do
{instructions}</code></pre>
<p>The <em>iterand</em> is a function or statement that expresses an
iteration; it could be the range 1..15, for example. <em>index</em> is a
variable that exists only in the context of the for-loop, and that will
be taking the different values yielded by the iterand. The code flows as
follows: index takes the first value yielded by the iterand, and keeps
it until all the instructions inside the curly brackets are executed one
by one; then, index takes the second value yielded by the iterand, and
keeps it until all the instructions are executed again. This pattern is
repeated until index takes all the different values expressed by the
iterand.</p>
<p>This <code>for</code> loop, for example</p>
<pre class="chpl"><code>// calculate the new temperatures (temp_new) using the past temperatures (temp)
for i in 1..rows do
{
  // do this for every row
}</code></pre>
<p>will allow us to iterate over the rows of <code>temp_new</code>. Now,
for each row we also need to iterate over all the columns in order to
access every single element of <code>temp_new</code>. This can be done
with nested <code>for</code> loops like this:</p>
<pre class="chpl"><code>// calculate the new temperatures (temp_new) using the past temperatures (temp)
for i in 1..rows do
{
  // do this for every row
  for j in 1..cols do
  {
    // and this for every column in the row i
  }
}</code></pre>
<p>Now, inside the inner loop, we can use the indices <code>i</code> and
<code>j</code> to perform the required computations as follows:</p>
<pre class="chpl"><code>// calculate the new temperatures (temp_new) using the past temperatures (temp)
for i in 1..rows do
{
  // do this for every row
  for j in 1..cols do
  {
    // and this for every column in the row i
    temp_new[i,j] = (temp[i-1,j] + temp[i+1,j] + temp[i,j-1] + temp[i,j+1]) / 4;
  }
}
temp=temp_new;</code></pre>
<p>Note that at the end of the outer <code>for</code> loop, when all the
elements in <code>temp_new</code> are already calculated, we update
<code>temp</code> with the values of <code>temp_new</code>; this way
everything is set up for the next iteration of the main
<code>while</code> statement.</p>
<p>Now let’s compile and execute our code again:</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="ex">chpl</span> base_solution.chpl</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a><span class="ex">./base_solution</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>The simulation will consider a matrix of 100 by 100 elements,
it will run up to 500 iterations, or until the largest difference
in temperature between iterations is less than 0.0001.
You are interested in the evolution of the temperature at the
position (50,50) of the matrix...

and here we go...
Temperature at iteration 0: 25.0
Temperature at iteration 20: 25.0
Temperature at iteration 40: 25.0
Temperature at iteration 60: 25.0
Temperature at iteration 80: 25.0
Temperature at iteration 100: 25.0
Temperature at iteration 120: 25.0
Temperature at iteration 140: 25.0
Temperature at iteration 160: 25.0
Temperature at iteration 180: 25.0
Temperature at iteration 200: 25.0
Temperature at iteration 220: 24.9999
Temperature at iteration 240: 24.9996
Temperature at iteration 260: 24.9991
Temperature at iteration 280: 24.9981
Temperature at iteration 300: 24.9963
Temperature at iteration 320: 24.9935
Temperature at iteration 340: 24.9893
Temperature at iteration 360: 24.9833
Temperature at iteration 380: 24.9752
Temperature at iteration 400: 24.9644
Temperature at iteration 420: 24.9507
Temperature at iteration 440: 24.9337
Temperature at iteration 460: 24.913
Temperature at iteration 480: 24.8883
Temperature at iteration 500: 24.8595</code></pre>
</div>
<p>As we can see, the temperature in the middle of the plate (position
50,50) is slowly decreasing as the plate is cooling down.</p>
<div id="challenge-1-can-you-do-it" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-1-can-you-do-it" class="callout-inner">
<h3 class="callout-title">Challenge 1: Can you do it?</h3>
<div class="callout-content">
<p>What would be the temperature at the top right corner of the plate?
In our current setup we have a layer of ghost points around the internal
grid. While the temperature on the internal grid was initially set to
25.0, the temperature at the ghost points was set to 0.0. Note that
during our iterations we do not compute the temperature at the ghost
points – it is permanently set to 0.0. Consequently, any point close to
the ghost layer will be influenced by this zero temperature, so we
expect the temperature near the border of the plate to decrease faster.
Modify the code to see the temperature at the top right corner.</p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<p>To see the evolution of the temperature at the top right corner of
the plate, we just need to modify <code>x</code> and <code>y</code>.
This corner correspond to the first row (<code>x=1</code>) and the last
column (<code>y=cols</code>) of the plate.</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="ex">chpl</span> base_solution.chpl</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="ex">./base_solution</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>The simulation will consider a matrix of 100 by 100 elements,
it will run up to 500 iterations, or until the largest difference
in temperature between iterations is less than 0.0001.
You are interested in the evolution of the temperature at the position (1,100) of the matrix...

and here we go...
Temperature at iteration 0: 25.0
Temperature at iteration 20: 1.48171
Temperature at iteration 40: 0.767179
...
Temperature at iteration 460: 0.068973
Temperature at iteration 480: 0.0661081
Temperature at iteration 500: 0.0634717</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="challenge-2-can-you-do-it" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-2-can-you-do-it" class="callout-inner">
<h3 class="callout-title">Challenge 2: Can you do it?</h3>
<div class="callout-content">
<p>Now let’s have some more interesting boundary conditions. Suppose
that the plate is heated by a source of 80 degrees located at the bottom
right corner, and that the temperature on the rest of the border
decreases linearly as one gets farther form the corner (see the image
below). Utilise for loops to setup the described boundary conditions.
Compile and run your code to see how the temperature is changing
now.</p>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" aria-labelledby="headingSolution2" data-bs-parent="#accordionSolution2">
<div class="accordion-body">
<p>To get the linear distribution, the 80 degrees must be divided by the
number of rows or columns in our plate. So, the following couple of
<code>for</code> loops at the start of time iteration will give us what
we want:</p>
<pre class="chpl"><code>// set the boundary conditions
for i in 1..rows do
  temp[i,cols+1] = i*80.0/rows;   // right side
for j in 1..cols do
  temp[rows+1,j] = j*80.0/cols;   // bottom side</code></pre>
<p>Note that 80 degrees is written as a real number 80.0. The division
of integers in Chapel returns an integer, then, as <code>rows</code> and
<code>cols</code> are integers, we must have 80 as real so that the
result is not truncated.</p>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="ex">chpl</span> base_solution.chpl</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a><span class="ex">./base_solution</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>The simulation will consider a matrix of 100 by 100 elements, it will run
up to 500 iterations, or until the largest difference in temperature
between iterations is less than 0.0001. You are interested in the evolution
of the temperature at the position (1,100) of the matrix...

and here we go...
Temperature at iteration 0: 25.0
Temperature at iteration 20: 2.0859
Temperature at iteration 40: 1.42663
...
Temperature at iteration 460: 0.826941
Temperature at iteration 480: 0.824959
Temperature at iteration 500: 0.823152</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="challenge-3-can-you-do-it" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-3-can-you-do-it" class="callout-inner">
<h3 class="callout-title">Challenge 3: Can you do it?</h3>
<div class="callout-content">
<p>Let us increase the maximum number of iterations to
<code>niter = 10_000</code>. The code now does 10_000 iterations:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>...
Temperature at iteration 9960: 0.79214
Temperature at iteration 9980: 0.792139
Temperature at iteration 10000: 0.792139</code></pre>
</div>
<p>So far, <code>delta</code> has been always equal to
<code>tolerance</code>, which means that our main <code>while</code>
loop will always run <code>niter</code> iterations. So let’s update
<code>delta</code> after each iteration. Use what we have studied so far
to write the required piece of code.</p>
</div>
</div>
</div>
<div id="accordionSolution3" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution3" aria-expanded="false" aria-controls="collapseSolution3">
  <h4 class="accordion-header" id="headingSolution3"> Show me the solution </h4>
</button>
<div id="collapseSolution3" class="accordion-collapse collapse" aria-labelledby="headingSolution3" data-bs-parent="#accordionSolution3">
<div class="accordion-body">
<p>The idea is simple, after each iteration of the while loop, we must
compare all elements of <code>temp_new</code> and <code>temp</code>,
find the greatest difference, and update <code>delta</code> with that
value. The next nested for loops do the job:</p>
<pre class="chpl"><code>// update delta, the greatest difference between temp_new and temp
delta=0;
for i in 1..rows do
{
  for j in 1..cols do
  {
    tmp = abs(temp_new[i,j]-temp[i,j]);
    if tmp &gt; delta then delta = tmp;
  }
}</code></pre>
<p>Clearly there is no need to keep the difference at every single
position in the array, we just need to update <code>delta</code> if we
find a greater one.</p>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="ex">chpl</span> base_solution.chpl</span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a><span class="ex">./base_solution</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>The simulation will consider a matrix of 100 by 100 elements,
it will run up to 10000 iterations, or until the largest difference
in temperature between iterations is less than 0.0001.
You are interested in the evolution of the temperature at the
position (1,100) of the matrix...

and here we go...
Temperature at iteration 0: 25.0
Temperature at iteration 20: 2.0859
Temperature at iteration 40: 1.42663
...
Temperature at iteration 7460: 0.792283
Temperature at iteration 7480: 0.792281
Temperature at iteration 7500: 0.792279

Final temperature at the desired position after 7505 iterations is: 0.792279
The difference in temperatures between the last two iterations was: 9.99834e-05</code></pre>
</div>
</div>
</div>
</div>
</div>
<p>Now, after Exercise 3 we should have a working program to simulate
our heat transfer equation. Let’s just print some additional useful
information,</p>
<pre class="chpl"><code>// print final information
writeln('\nFinal temperature at the desired position after ',c,' iterations is: ',temp[x,y]);
writeln('The difference in temperatures between the last two iterations was: ',delta,'\n');</code></pre>
<p>and compile and execute our final code,</p>
<div class="codewrapper sourceCode" id="cb17">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a><span class="ex">chpl</span> base_solution.chpl</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a><span class="ex">./base_solution</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>The simulation will consider a matrix of 100 by 100 elements,
it will run up to 500 iterations, or until the largest difference
in temperature between iterations is less than 0.0001.
You are interested in the evolution of the temperature at the
position (1,100) of the matrix...

and here we go...
Temperature at iteration 0: 25.0
Temperature at iteration 20: 2.0859
Temperature at iteration 40: 1.42663
Temperature at iteration 60: 1.20229
Temperature at iteration 80: 1.09044
Temperature at iteration 100: 1.02391
Temperature at iteration 120: 0.980011
Temperature at iteration 140: 0.949004
Temperature at iteration 160: 0.926011
Temperature at iteration 180: 0.908328
Temperature at iteration 200: 0.894339
Temperature at iteration 220: 0.88302
Temperature at iteration 240: 0.873688
Temperature at iteration 260: 0.865876
Temperature at iteration 280: 0.85925
Temperature at iteration 300: 0.853567
Temperature at iteration 320: 0.848644
Temperature at iteration 340: 0.844343
Temperature at iteration 360: 0.840559
Temperature at iteration 380: 0.837205
Temperature at iteration 400: 0.834216
Temperature at iteration 420: 0.831537
Temperature at iteration 440: 0.829124
Temperature at iteration 460: 0.826941
Temperature at iteration 480: 0.824959
Temperature at iteration 500: 0.823152

Final temperature at the desired position after 500 iterations is: 0.823152
The greatest difference in temperatures between the last two iterations was: 0.0258874</code></pre>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>“You can organize loops with <code>for</code> and <code>while</code>
statements. Use a <code>for</code> loop to run over every element of the
iterand, e.g. <code>for i in 1..rows do { ...}</code> will run over all
integers from 1 to <code>rows</code>. Use a <code>while</code> statement
to repeatedly execute a code block until the condition does not hold
anymore,
e.g. <code>while (c &lt;   niter &amp;&amp; delta &gt;= tolerance) do {...}</code>
will repeatedly execute the commands in curly braces until one of the
two conditions turns false.”</li>
</ul>
</div>
</div>
</div></section><section id="aio-06-procedures"><p>Content from <a href="06-procedures.html">Procedures</a></p>
<hr>
<p>Last updated on 2024-10-08 |

        <a href="https://github.com/hpc-carpentry/hpc-chapel/edit/main/episodes/06-procedures.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 15 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>“How do I write functions?”</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>“Be able to write our own procedures.”</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<p>Similar to other programming languages, Chapel lets you define your
own functions. These are called ‘procedures’ in Chapel and have an
easy-to-understand syntax:</p>
<pre class="chpl"><code>proc addOne(n) { // n is an input parameter
  return n + 1;
}</code></pre>
<p>To call this procedure, you would use its name:</p>
<pre class="chpl"><code><span><span class="fu">writeln</span><span class="op">(</span><span class="fu">addOne</span><span class="op">(</span><span class="fl">10</span><span class="op">)</span><span class="op">)</span>;</span></code></pre>
<p>Procedures can be recursive, as demonstrated below. In this example
the procedure takes an integer number as a parameter and returns an
integer number – more on this below. If the input parameter is 1 or 0,
<code>fibonacci</code> will return the same input parameter. If the
input parameter is 2 or larger, <code>fibonacci</code> will call itself
recursively.</p>
<pre class="chpl"><code>proc fibonacci(n: int): int { // input parameter type and procedure return type, respectively
  if n &lt;= 1 then return n;
  return fibonacci(n-1) + fibonacci(n-2);
}</code></pre>
<pre class="chpl"><code><span><span class="fu">writeln</span><span class="op">(</span><span class="fu">fibonacci</span><span class="op">(</span><span class="fl">10</span><span class="op">)</span><span class="op">)</span>;</span></code></pre>
<p>The input parameter type <code>n: int</code> is enforced at
compilation time. For example, if you try to pass a real-type number to
the procedure with <code>fibonacci(10.2)</code>, you will get an error
“error: unresolved call”. Similarly, the return variable type is also
enforced at compilation time. For example, replacing
<code>return n</code> with <code>return 1.0</code> in line 2 will result
in “error: cannot initialize return value of type ‘int(64)’”. While
specifying these types might be optional (see the call out below), we
highly recommend doing so in your code, as it will add additional checks
for your program.</p>
<div id="callout1" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Callout</h3>
<div class="callout-content">
<p>If not specified, the procedure return type is inferred from the
return variable type. This might not be possible with a recursive
procedure as the return type is the procedure type, and it is not known
to the compiler, so in this case (and in the <code>fibonacci</code>
example above) we need to specify the procedure return type
explicitly.</p>
</div>
</div>
</div>
<p>Procedures can take a varying number of parameters. In this example
the procedure <code>maxOf</code> takes two or more parameters of the
same type. This group of parameters is referred to as a <em>tuple</em>
and is named <code>x</code> inside the procedure. The number of elements
<code>k</code> in this tuple is inferred from the number of parameters
passed to the procedure and is used to organize the calculations inside
the procedure:</p>
<pre class="chpl"><code>proc maxOf(x ...?k) { // take a tuple of one type with k elements
  var maximum = x[1];
  for i in 2..k do maximum = if maximum &lt; x[i] then x[i] else maximum;
  return maximum;
}</code></pre>
<pre class="chpl"><code><span><span class="fu">writeln</span><span class="op">(</span><span class="fu">maxOf</span><span class="op">(</span><span class="fl">1</span>, <span class="op">-</span><span class="fl">5</span>, <span class="fl">123</span>, <span class="fl">85</span>, <span class="op">-</span><span class="fl">17</span>, <span class="fl">3</span><span class="op">)</span><span class="op">)</span>;</span>
<span><span class="fu">writeln</span><span class="op">(</span><span class="fu">maxOf</span><span class="op">(</span><span class="fl">1.12</span>, <span class="fl">0.85</span>, <span class="fl">2.35</span><span class="op">)</span><span class="op">)</span>;</span></code></pre>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code><span><span class="fl">123</span></span>
<span><span class="fl">2.35</span></span></code></pre>
</div>
<p>Procedures can have default parameter values. If a parameter with the
default value (like <code>y</code> in the example below) is not passed
to the procedure, it takes the default value inside the procedure. If it
is passed with another value, then this new value is used inside the
procedure.</p>
<p>In Chapel a procedure always returns a single value or a single data
structure. In this example the procedure returns a <em>tuple</em> (a
structure) with two numbers inside, one integer and one real:</p>
<pre class="chpl"><code>proc returnTuple(x: int, y: real = 3.1415926): (int,real) {
  return (x,y);
}</code></pre>
<pre class="chpl"><code>writeln(returnTuple(1));
writeln(returnTuple(x=2));
writeln(returnTuple(x=-10, y=10));
writeln(returnTuple(y=-1, x=3)); // the parameters can be named out of order</code></pre>
<p>Chapel procedures have many other useful features, however, they are
not essential for learning task and data parallelism, so we refer the
interested readers to the official Chapel documentation.</p>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>“Functions in Chapel are called procedures.”</li>
<li>“Procedures can take a varying number of parameters.”</li>
<li>“Optionally, you can specify input parameter types and the return
variable type.”</li>
<li>“Procedures can have default parameter values.”</li>
<li>“Procedures can be recursive. Recursive procedures require
specifying the return variable type.”</li>
</ul>
</div>
</div>
</div></section><section id="aio-07-commandargs"><p>Content from <a href="07-commandargs.html">Using command-line arguments</a></p>
<hr>
<p>Last updated on 2024-10-08 |

        <a href="https://github.com/hpc-carpentry/hpc-chapel/edit/main/episodes/07-commandargs.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 90 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>“How do I use the same program for multiple use-cases?”</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>“Modifying code’s constant parameters without re-compiling the
code.”</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<p>From the last run of our code, we can see that 500 iterations is not
enough to get to a <em>steady state</em> (a state where the difference
in temperature does not vary too much,
i.e. <code>delta</code>&lt;<code>tolerance</code>). Now, if we want to
change the number of iterations we would need to modify
<code>niter</code> in the code, and compile it again. What if we want to
change the number of rows and columns in our grid to have more
precision, or if we want to see the evolution of the temperature at a
different point (x,y)? The answer would be the same, modify the code and
compile it again!</p>
<p>No need to say that this would be very tedious and inefficient. A
better scenario would be if we can pass the desired configuration values
to our binary when it is called at the command line. The Chapel
mechanism for this is to use <strong><em>config</em></strong> variables.
When a variable is declared with the <code>config</code> keyword, in
addition to <code>var</code> or <code>const</code>, like this:</p>
<pre class="chpl"><code>config const niter = 500;    //number of iterations</code></pre>
<p>it can be initialised with a specific value, when executing the code
at the command line, using the syntax:</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="ex">chpl</span> base_solution.chpl</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="ex">./base_solution</span> <span class="at">--niter</span><span class="op">=</span>3000</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>The simulation will consider a matrix of 100 by 100 elements,
it will run up to 3000 iterations, or until the largest difference
in temperature between iterations is less than 0.0001.
You are interested in the evolution of the temperature at the
position (1,100) of the matrix...

and here we go...
Temperature at iteration 0: 25.0
Temperature at iteration 20: 2.0859
Temperature at iteration 40: 1.42663
...
Temperature at iteration 2980: 0.793969
Temperature at iteration 3000: 0.793947

Final temperature at the desired position after 3000 iterations is: 0.793947
The greatest difference in temperatures between the last two iterations was: 0.000350086</code></pre>
</div>
<div id="challenge-4-can-you-do-it" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-4-can-you-do-it" class="callout-inner">
<h3 class="callout-title">Challenge 4: Can you do it?</h3>
<div class="callout-content">
<p>Make <code>outputFrequency</code>, <code>x</code>, <code>y</code>,
<code>tolerance</code>, <code>rows</code> and <code>cols</code>
configurable variables, and test the code simulating different
configurations. What can you conclude about the performance of the
code?</p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<p>Let’s prepend <code>config</code> to the following lines in our
code:</p>
<pre class="chpl"><code>config const rows = 100;               // number of rows in the grid
config const cols = 100;               // number of columns in the grid
config const niter = 10_000;           // maximum number of iterations
config const x = 1;                    // row number for a printout
config const y = cols;                 // column number for a printout
config const tolerance: real = 0.0001; // smallest difference in temperature that would be accepted before stopping
config const outputFrequency: int = 20;   // the temperature will be printed every outputFrequency iterations</code></pre>
<p>We can then recompile the code and try modifying some of these
parameters from the command line. For example, let’s use a 650 x 650
grid and observe the evolution of the temperature at the position
(200,300) for 10,000 iterations or until the difference of temperature
between iterations is less than 0.002; also, let’s print the temperature
every 1000 iterations.</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="ex">chpl</span> base_solution.chpl</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a><span class="ex">./base_solution</span> <span class="at">--rows</span><span class="op">=</span>650 <span class="at">--cols</span><span class="op">=</span>650 <span class="at">--x</span><span class="op">=</span>200 <span class="at">--y</span><span class="op">=</span>300 <span class="at">--tolerance</span><span class="op">=</span>0.002 <span class="at">--outputFrequency</span><span class="op">=</span>1000</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>The simulation will consider a matrix of 650 by 650 elements, it will run up to 10000 iterations, or until
the largest difference in temperature between iterations is less than 0.002.  You are interested in the
evolution of the temperature at the position (200,300) of the matrix...

and here we go...
Temperature at iteration 0: 25.0
Temperature at iteration 1000: 25.0
Temperature at iteration 2000: 25.0
Temperature at iteration 3000: 25.0
Temperature at iteration 4000: 24.9998
Temperature at iteration 5000: 24.9984
Temperature at iteration 6000: 24.9935
Temperature at iteration 7000: 24.9819

Final temperature at the desired position after 7750 iterations is: 24.9671
The greatest difference in temperatures between the last two iterations was: 0.00199985</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>“Config variables accept values from the command line at runtime,
without you having to recompile the code.”</li>
</ul>
</div>
</div>
</div></section><section id="aio-08-timing"><p>Content from <a href="08-timing.html">Measuring code performance</a></p>
<hr>
<p>Last updated on 2024-10-08 |

        <a href="https://github.com/hpc-carpentry/hpc-chapel/edit/main/episodes/08-timing.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 90 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>“How do I know how fast my code is?”</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>“Measuring code performance by instrumenting the code.”</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<p>The code generated after Exercise 4 is the basic implementation of
our simulation. We will use it as a benchmark, to see how much we can
improve the performance when introducing the parallel programming
features of the language in the following lessons.</p>
<p>But first, we need a quantitative way to measure the performance of
our code. The easiest way to do it is to see how long it takes to finish
a simulation. The UNIX command <code>time</code> could be used to this
effect</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="bu">time</span> ./base_solution <span class="at">--rows</span><span class="op">=</span>650 <span class="at">--cols</span><span class="op">=</span>650 <span class="at">--x</span><span class="op">=</span>200 <span class="at">--y</span><span class="op">=</span>300 <span class="at">--tolerance</span><span class="op">=</span>0.002 <span class="at">--outputFrequency</span><span class="op">=</span>1000</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>The simulation will consider a matrix of 650 by 650 elements,
it will run up to 10000 iterations, or until the largest difference
in temperature between iterations is less than 0.002.
You are interested in the evolution of the temperature at the
position (200,300) of the matrix...

and here we go...
Temperature at iteration 0: 25.0
Temperature at iteration 1000: 25.0
Temperature at iteration 2000: 25.0
Temperature at iteration 3000: 25.0
Temperature at iteration 4000: 24.9998
Temperature at iteration 5000: 24.9984
Temperature at iteration 6000: 24.9935
Temperature at iteration 7000: 24.9819

Final temperature at the desired position after 7750 iterations is: 24.9671
The greatest difference in temperatures between the last two iterations was: 0.00199985

real	0m20.381s
user	0m20.328s
sys	0m0.053s</code></pre>
</div>
<p>The real time is what interests us. Our code is taking around 20
seconds from the moment it is called at the command line until it
returns.</p>
<p>Some times, however, it could be useful to take the execution time of
specific parts of the code. This can be achieved by modifying the code
to output the information that we need. This process is called
<strong><em>instrumentation of code</em></strong>.</p>
<p>An easy way to instrument our code with Chapel is by using the module
<code>Time</code>. <strong><em>Modules</em></strong> in Chapel are
libraries of useful functions and methods that can be used once the
module is loaded. To load a module we use the keyword <code>use</code>
followed by the name of the module. Once the Time module is loaded we
can create a variable of the type <code>stopwatch</code>, and use the
methods <code>start</code>,<code>stop</code>and <code>elapsed</code> to
instrument our code.</p>
<pre class="chpl"><code>use Time;
var watch: stopwatch;
watch.start();

//this is the main loop of the simulation
delta=tolerance;
while (c&lt;niter &amp;&amp; delta&gt;=tolerance) do
{
...
}

watch.stop();

//print final information
writeln('\nThe simulation took ',watch.elapsed(),' seconds');
writeln('Final temperature at the desired position after ',c,' iterations is: ',temp[x,y]);
writeln('The greatest difference in temperatures between the last two iterations was: ',delta,'\n');</code></pre>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="ex">chpl</span> base_solution.chpl</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a><span class="ex">./base_solution</span> <span class="at">--rows</span><span class="op">=</span>650 <span class="at">--cols</span><span class="op">=</span>650 <span class="at">--x</span><span class="op">=</span>200 <span class="at">--y</span><span class="op">=</span>300 <span class="at">--tolerance</span><span class="op">=</span>0.002 <span class="at">--outputFrequency</span><span class="op">=</span>1000</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>The simulation will consider a matrix of 650 by 650 elements,
it will run up to 10000 iterations, or until the largest difference
in temperature between iterations is less than 0.002.
You are interested in the evolution of the temperature at the
position (200,300) of the matrix...

and here we go...
Temperature at iteration 0: 25.0
Temperature at iteration 1000: 25.0
Temperature at iteration 2000: 25.0
Temperature at iteration 3000: 25.0
Temperature at iteration 4000: 24.9998
Temperature at iteration 5000: 24.9984
Temperature at iteration 6000: 24.9935
Temperature at iteration 7000: 24.9819

The simulation took 20.1621 seconds
Final temperature at the desired position after 7750 iterations is: 24.9671
The greatest difference in temperatures between the last two iterations was: 0.00199985</code></pre>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>“To measure performance, instrument your Chapel code using a
stopwatch from the <code>Time</code> module.”</li>
</ul>
</div>
</div>
</div></section><section id="aio-11-parallel-intro"><p>Content from <a href="11-parallel-intro.html">Intro to parallel computing</a></p>
<hr>
<p>Last updated on 2024-10-08 |

        <a href="https://github.com/hpc-carpentry/hpc-chapel/edit/main/episodes/11-parallel-intro.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 90 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>“How does parallel processing work?”</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>“Discuss some common concepts in parallel computing.”</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<p>The basic concept of parallel computing is simple to understand: we
divide our job into tasks that can be executed at the same time, so that
we finish the job in a fraction of the time that it would have taken if
the tasks were executed one by one. Implementing parallel computations,
however, is not always easy, nor possible…</p>
<p>Consider the following analogy:</p>
<p>Suppose that we want to paint the four walls in a room. We’ll call
this the <em>problem</em>. We can divide our problem into 4 different
tasks: paint each of the walls. In principle, our 4 tasks are
independent from each other in the sense that we don’t need to finish
one to start one another. We say that we have 4 <strong><em>concurrent
tasks</em></strong>; the tasks can be executed within the same time
frame. However, this does not mean that the tasks can be executed
simultaneously or in parallel. It all depends on the amount of resources
that we have for the tasks. If there is only one painter, this guy could
work for a while in one wall, then start painting another one, then work
for a little bit on the third one, and so on. <strong><em>The tasks are
being executed concurrently but not in parallel</em></strong>. If we
have two painters for the job, then more parallelism can be introduced.
Four painters could execute the tasks <strong><em>truly in
parallel</em></strong>.</p>
<div id="callout1" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Callout</h3>
<div class="callout-content">
<p>Think of the CPU cores as the painters or workers that will execute
your concurrent tasks.</p>
</div>
</div>
</div>
<p>Now imagine that all workers have to obtain their paint from a
central dispenser located at the middle of the room. If each worker is
using a different colour, then they can work
<strong><em>asynchronously</em></strong>, however, if they use the same
colour, and two of them run out of paint at the same time, then they
have to <strong><em>synchronise</em></strong> to use the dispenser: One
must wait while the other is being serviced.</p>
<div id="callout2" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Callout</h3>
<div class="callout-content">
<p>Think of the shared memory in your computer as the central dispenser
for all your workers.</p>
</div>
</div>
</div>
<p>Finally, imagine that we have 4 paint dispensers, one for each
worker. In this scenario, each worker can complete their task totally on
their own. They don’t even have to be in the same room, they could be
painting walls of different rooms in the house, in different houses in
the city, and different cities in the country. We need, however, a
communication system in place. Suppose that worker A, for some reason,
needs a colour that is only available in the dispenser of worker B, they
must then synchronise: worker A must request the paint of worker B and
worker B must respond by sending the required colour.</p>
<div id="callout3" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Callout</h3>
<div class="callout-content">
<p>Think of the memory on each node of a cluster as a separate dispenser
for your workers.</p>
</div>
</div>
</div>
<p>A <strong><em>fine-grained</em></strong> parallel code needs lots of
communication or synchronisation between tasks, in contrast with a
<strong><em>coarse-grained</em></strong> one. An
<strong><em>embarrassingly parallel</em></strong> problem is one where
all tasks can be executed completely independent from each other (no
communications required).</p>
<section><h2 class="section-heading" id="parallel-programming-in-chapel">Parallel programming in Chapel<a class="anchor" aria-label="anchor" href="#parallel-programming-in-chapel"></a>
</h2>
<hr class="half-width">
<p>Chapel provides high-level abstractions for parallel programming no
matter the grain size of your tasks, whether they run in a shared memory
on one node or use memory distributed across multiple compute nodes, or
whether they are executed concurrently or truly in parallel. As a
programmer you can focus in the algorithm: how to divide the problem
into tasks that make sense in the context of the problem, and be sure
that the high-level implementation will run on any hardware
configuration. Then you could consider the details of the specific
system you are going to use (whether it is shared or distributed, the
number of cores, etc.) and tune your code/algorithm to obtain a better
performance.</p>
<div id="callout4" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Callout</h3>
<div class="callout-content">
<p>To this effect, <strong><em>concurrency</em></strong> (the creation
and execution of multiple tasks), and <strong><em>locality</em></strong>
(in which set of resources these tasks are executed) are orthogonal
concepts in Chapel.</p>
</div>
</div>
</div>
<p>In summary, we can have a set of several tasks; these tasks could be
running:</p>
<ol style="list-style-type: decimal">
<li>concurrently by the same processor in a single compute node,</li>
<li>in parallel by several processors in a single compute node,</li>
<li>in parallel by several processors distributed in different compute
nodes, or</li>
<li>serially (one by one) by several processors distributed in different
compute nodes.</li>
</ol>
<p>Similarly, each of these tasks could be using variables</p>
<ol style="list-style-type: decimal">
<li>located in the local memory on the compute node where it is running,
or</li>
<li>stored on other compute nodes.</li>
</ol>
<p>And again, Chapel could take care of all the stuff required to run
our algorithm in most of the scenarios, but we can always add more
specific detail to gain performance when targeting a particular
scenario.</p>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>“Concurrency and locality are orthogonal concepts in Chapel: where
the tasks are running may not be indicative of when they run, and you
can control both in Chapel.”</li>
<li>“Problems with a lot of communication between tasks, or so called
<strong><em>fine-grained</em></strong> parallel problems, are typically
more difficult to parallelize. As we will see later in these lessons,
Chapel simplifies writing <strong><em>fine-grained</em></strong>
parallel codes by hiding a lot of communication complexity under the
hood.”</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-12-fire-forget-tasks"><p>Content from <a href="12-fire-forget-tasks.html">Fire-and-forget tasks</a></p>
<hr>
<p>Last updated on 2024-10-08 |

        <a href="https://github.com/hpc-carpentry/hpc-chapel/edit/main/episodes/12-fire-forget-tasks.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 90 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>“How do we execute work in parallel?”</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>“Launching multiple threads to execute tasks in parallel.”</li>
<li>“Learn how to use <code>begin</code>, <code>cobegin</code>, and
<code>coforall</code> to spawn new tasks.”</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="callout1" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Callout</h3>
<div class="callout-content">
<p>In the very first chapter where we showed how to run single-node
Chapel codes. As a refresher, let’s go over this again. If you are
running Chapel on your own computer, then you are all set, and you can
simply compile and run Chapel codes. If you are on a cluster, you will
need to run Chapel codes inside interactive jobs. Here so far we are
covering only single-locale Chapel, so – from the login node – you can
submit an interactive job to the scheduler with a command like this
one:</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">SH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode sh" tabindex="0"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="ex">salloc</span> <span class="at">--time</span><span class="op">=</span>2:0:0 <span class="at">--ntasks</span><span class="op">=</span>1 <span class="at">--cpus-per-task</span><span class="op">=</span>3 <span class="at">--mem-per-cpu</span><span class="op">=</span>1000</span></code></pre>
</div>
<p>The details may vary depending on your cluster, e.g. different
scheduler, requirement to specify an account or reservation, etc, but
the general idea remains the same: on a cluster you need to ask for
resources before you can run calculations. In this case we are asking
for 2 hours maximum runtime, single MPI task (sufficient for our
parallelism in this chapter), 3 CPU cores inside that task, and 1000M
maximum memory per core. The core count means that we can run 3 threads
in parallel, each on its own CPU core. Once your interactive job starts,
you can compile and run the Chapel codes below. Inside your Chapel code,
when new threads start, they will be able to utilize our 3 allocated CPU
cores.</p>
</div>
</div>
</div>
<p>A Chapel program always start as a single main thread. You can then
start concurrent tasks with the <code>begin</code> statement. A task
spawned by the <code>begin</code> statement will run in a different
thread while the main thread continues its normal execution. Consider
the following example:</p>
<pre class="chpl"><code>var x = 0;

writeln("This is the main thread starting first task");
begin
{
  var c = 0;
  while c &lt; 10
  {
    c += 1;
    writeln('thread 1: ', x+c);
  }
}

writeln("This is the main thread starting second task");
begin
{
  var c = 0;
  while c &lt; 10
  {
    c += 1;
    writeln('thread 2: ', x+c);
  }
}

writeln('this is main thread, I am done...');</code></pre>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="ex">chpl</span> begin_example.chpl</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a><span class="ex">./begin_example</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>This is the main thread starting first task
This is the main thread starting second task
this is main thread, I am done...
thread 1: 1
thread 1: 2
thread 1: 3
thread 1: 4
thread 1: 5
thread 1: 6
thread 1: 7
thread 1: 8
thread 1: 9
thread 1: 10
thread 2: 1
thread 2: 2
thread 2: 3
thread 2: 4
thread 2: 5
thread 2: 6
thread 2: 7
thread 2: 8
thread 2: 9
thread 2: 10</code></pre>
</div>
<p>As you can see the order of the output is not what we would expected,
and actually it is completely unpredictable. This is a well known effect
of concurrent tasks accessing the same shared resource at the same time
(in this case the screen); the system decides in which order the tasks
could write to the screen.</p>
<div id="challenge-1-what-if-c-is-defined-globally" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-1-what-if-c-is-defined-globally" class="callout-inner">
<h3 class="callout-title">Challenge 1: what if <code>c</code> is defined
globally?</h3>
<div class="callout-content">
<p>What would happen if in the last code we <em>move</em> the definition
of <code>c</code> into the main thread, but try to assign it from
threads 1 and 2? Select one answer from these:</p>
<ol style="list-style-type: decimal">
<li>The code will fail to compile.</li>
<li>The code will compile and run, but <code>c</code> will be updated by
both threads at the same time (a <em>race condition</em>), so that its
final value will vary from one run to another.</li>
<li>The code will compile and run, and the two threads will be taking
turns updating <code>c</code>, so that its final value will always be
the same.</li>
</ol>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<p>We’ll get an error at compilation (“cannot assign to const
variable”), since then <code>c</code> would be defined within the scope
of the main thread, and we could modify its value only in the main
thread. Any attempt to modify its value inside threads 1 or 2 will
produce a compilation error.</p>
</div>
</div>
</div>
</div>
<div id="challenge-2-what-if-we-have-a-second-local-definition-of-x" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-2-what-if-we-have-a-second-local-definition-of-x" class="callout-inner">
<h3 class="callout-title">Challenge 2: what if we have a second, local
definition of <code>x</code>?</h3>
<div class="callout-content">
<p>What would happen if we try to insert a second definition
<code>var x = 10;</code> inside the first <code>begin</code> statement?
Select one answer from these:</p>
<ol style="list-style-type: decimal">
<li>The code will fail to compile.</li>
<li>The code will compile and run, and the inside the first
<code>begin</code> statement the value <code>x = 10</code> will be used,
whereas inside the second <code>begin</code> statement the value
<code>x = 0</code> will be used.</li>
<li>The new value <code>x = 10</code> will overwrite the global value
<code>x = 0</code> in both threads 1 and 2.</li>
</ol>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" data-bs-parent="#accordionSolution2" aria-labelledby="headingSolution2">
<div class="accordion-body">
<p>The code will compile and run, and you will see the following
output:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>This is the main thread starting first task
This is the main thread starting second task
this is main thread, I am done...
thread 1: 11
thread 1: 12
thread 1: 13
thread 1: 14
thread 1: 15
thread 1: 16
thread 1: 17
thread 1: 18
thread 1: 19
thread 1: 20
thread 2: 1
thread 2: 2
thread 2: 3
thread 2: 4
thread 2: 5
thread 2: 6
thread 2: 7
thread 2: 8
thread 2: 9
thread 2: 10</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="callout2" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Callout</h3>
<div class="callout-content">
<p>All variables have a <strong><em>scope</em></strong> in which they
can be used. The variables declared inside a concurrent task are
accessible only by that task. The variables declared in the main task
can be read everywhere, but Chapel won’t allow other concurrent tasks to
modify them.</p>
</div>
</div>
</div>
<div id="try-this" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="try-this" class="callout-inner">
<h3 class="callout-title">Try this …</h3>
<div class="callout-content">
<p>Are the concurrent tasks, spawned by the last code, running truly in
parallel?</p>
<p>The answer is: it depends on the number of cores available to your
Chapel code. To verify this, let’s modify the code to get both threads 1
and 2 into an infinite loop:</p>
<pre class="chpl"><code>begin
{
  var c=0;
  while c &gt; -1
  {
       c += 1;
      // the rest of the code in the thread
   }
}</code></pre>
<p>Compile and run the code:</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">SH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode sh" tabindex="0"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="ex">chpl</span> begin_example.chpl</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="ex">./begin_example</span></span></code></pre>
</div>
<p>If you are running this on your own computer, you can run
<code>top</code> or <code>htop</code> or <code>ps</code> commands in
another terminal to check Chapel’s CPU usage. If you are running inside
an interactive job on a cluster, you can open a different terminal, log
in to the cluster, and open a bash shell on the node that is running
your job (if your cluster setup allows this):</p>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">SH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode sh" tabindex="0"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="ex">squeue</span> <span class="at">-u</span> <span class="va">$USER</span>                   <span class="co"># check the jobID number</span></span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a><span class="ex">srun</span> <span class="at">--jobid</span><span class="op">=&lt;</span>jobID<span class="op">&gt;</span> --pty bash   <span class="co"># put your jobID here</span></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a><span class="ex">htop</span> <span class="at">-u</span> <span class="va">$USER</span> <span class="at">-s</span> PERCENT_CPU      <span class="co"># display CPU usage and other information</span></span></code></pre>
</div>
<p>In the output of <code>htop</code> you will see a table with the list
of your processes, and in the “CPU%” column you will see the percentage
consumed by each process. Find the Chapel process, and if it shows that
your CPU usage is close to 300%, you are using 3 CPU cores. What do you
see?</p>
<p>Now exit <code>htop</code> by pressing <em>Q</em>. Also exit your
interactive run by pressing <em>Ctrl-C</em>.</p>
</div>
</div>
</div>
<div id="callout3" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Callout</h3>
<div class="callout-content">
<p>To maximise performance, start as many tasks as cores are
available.</p>
</div>
</div>
</div>
<p>A slightly more structured way to start concurrent tasks in Chapel is
by using the <code>cobegin</code>statement. Here you can start a block
of concurrent tasks, one for each statement inside the curly brackets.
The main difference between the <code>begin</code>and
<code>cobegin</code> statements is that with the <code>cobegin</code>,
all the spawned tasks are synchronised at the end of the statement,
i.e. the main thread won’t continue its execution until all tasks are
done.</p>
<pre class="chpl"><code>var x=0;
writeln("This is the main thread, my value of x is ",x);

cobegin
{
  {
    var x=5;
    writeln("this is task 1, my value of x is ",x);
  }
  writeln("this is task 2, my value of x is ",x);
}

writeln("this message won't appear until all tasks are done...");</code></pre>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="ex">chpl</span> cobegin_example.chpl</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a><span class="ex">./cobegin_example</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>This is the main thread, my value of x is 0
this is task 2, my value of x is 0
this is task 1, my value of x is 5
this message won't appear until all tasks are done...</code></pre>
</div>
<p>As you may have conclude from the Discussion exercise above, the
variables declared inside a task are accessible only by the task, while
those variables declared in the main task are accessible to all
tasks.</p>
<p>The last, and most useful way to start concurrent/parallel tasks in
Chapel, is the <code>coforall</code> loop. This is a combination of the
for-loop and the <code>cobegin</code>statements. The general syntax
is:</p>
<pre class="chpl"><code>coforall index in iterand
{instructions}</code></pre>
<p>This will start a new task, for each iteration. Each tasks will then
perform all the instructions inside the curly brackets. Each task will
have a copy of the variable <strong><em>index</em></strong> with the
corresponding value yielded by the iterand. This index allows us to
<em>customise</em> the set of instructions for each particular task.</p>
<pre class="chpl"><code>var x=1;
config var numoftasks=2;

writeln("This is the main task: x = ",x);

coforall taskid in 1..numoftasks do
{
  var c=taskid+1;
  writeln("this is task ",taskid,": x + ",taskid," = ",x+taskid,". My value of c is: ",c);
}

writeln("this message won't appear until all tasks are done...");</code></pre>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="ex">chpl</span> coforall_example.chpl</span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a><span class="ex">./coforall_example</span> <span class="at">--numoftasks</span><span class="op">=</span>5</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>This is the main task: x = 1
this is task 5: x + 5 = 6. My value of c is: 6
this is task 2: x + 2 = 3. My value of c is: 3
this is task 4: x + 4 = 5. My value of c is: 5
this is task 3: x + 3 = 4. My value of c is: 4
this is task 1: x + 1 = 2. My value of c is: 2
this message won't appear until all tasks are done...</code></pre>
</div>
<p>Notice how we are able to customise the instructions inside the
coforall, to give different results depending on the task that is
executing them. Also, notice how, once again, the variables declared
outside the coforall can be read by all tasks, while the variables
declared inside, are available only to the particular task.</p>
<div id="challenge-3-can-you-do-it" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-3-can-you-do-it" class="callout-inner">
<h3 class="callout-title">Challenge 3: Can you do it?</h3>
<div class="callout-content">
<p>Would it be possible to print all the messages in the right order?
Modify the code in the last example as required.</p>
<p>Hint: you can use an array of strings declared in the main task,
where all the concurrent tasks could write their messages in the
corresponding position. Then, at the end, have the main task printing
all elements of the array in order.</p>
</div>
</div>
</div>
<div id="accordionSolution3" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution3" aria-expanded="false" aria-controls="collapseSolution3">
  <h4 class="accordion-header" id="headingSolution3"> Show me the solution </h4>
</button>
<div id="collapseSolution3" class="accordion-collapse collapse" data-bs-parent="#accordionSolution3" aria-labelledby="headingSolution3">
<div class="accordion-body">
<p>The following code is a possible solution:</p>
<pre class="chpl"><code>var x = 1;
config var numoftasks = 2;
var messages: [1..numoftasks] string;

writeln("This is the main task: x = ", x);

coforall taskid in 1..numoftasks do {
  var c = taskid + 1;
  messages[taskid] = 'this is task ' + taskid:string +
    ': my value of c is ' + c:string + ' and x is ' + x:string;
}

for i in 1..numoftasks do writeln(messages[i]);
writeln("this message won't appear until all tasks are done...");</code></pre>
<div class="codewrapper sourceCode" id="cb17">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a><span class="ex">chpl</span> exercise_coforall.chpl</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a><span class="ex">./exercise_coforall</span> <span class="at">--numoftasks</span><span class="op">=</span>5</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>This is the main task: x = 1
this is task 1: x + 1 = 2. My value of c is: 2
this is task 2: x + 2 = 3. My value of c is: 3
this is task 3: x + 3 = 4. My value of c is: 4
this is task 4: x + 4 = 5. My value of c is: 5
this is task 5: x + 5 = 6. My value of c is: 6
this message won't appear until all tasks are done...</code></pre>
</div>
<p>Note that we need to convert integers to strings first
(<code>taskid:string</code> converts <code>taskid</code> integer
variable to a string) before we can add them to other strings to form a
message stored inside each <code>messages</code> element.</p>
</div>
</div>
</div>
</div>
<div id="challenge-4-can-you-do-it" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-4-can-you-do-it" class="callout-inner">
<h3 class="callout-title">Challenge 4: Can you do it?</h3>
<div class="callout-content">
<p>Consider the following code:</p>
<pre class="chpl"><code>use Random;
config const nelem = 100_000_000;
var x: [1..nelem] int;
fillRandom(x);	//fill array with random numbers
var mymax = 0;

// here put your code to find mymax

writeln("the maximum value in x is: ", mymax);</code></pre>
<p>Write a parallel code to find the maximum value in the array x.</p>
</div>
</div>
</div>
<div id="accordionSolution4" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution4" aria-expanded="false" aria-controls="collapseSolution4">
  <h4 class="accordion-header" id="headingSolution4"> Show me the solution </h4>
</button>
<div id="collapseSolution4" class="accordion-collapse collapse" data-bs-parent="#accordionSolution4" aria-labelledby="headingSolution4">
<div class="accordion-body">
<pre class="chpl"><code>config const numtasks = 12;
const n = nelem/numtasks;     // number of elements per thread
const r = nelem - n*numtasks; // these elements did not fit into the last thread

var d: [1..numtasks] int;  // local maxima for each thread

coforall taskid in 1..numtasks do {
  var i, f: int;
  i  = (taskid-1)*n + 1;
  f = (taskid-1)*n + n;
  if taskid == numtasks then f += r; // add r elements to the last thread
  for j in i..f do
    if x[j] &gt; d[taskid] then d[taskid] = x[j];
}
for i in 1..numtasks do
  if d[i] &gt; mymax then mymax = d[i];</code></pre>
<div class="codewrapper sourceCode" id="cb21">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a><span class="ex">chpl</span> <span class="at">--fast</span> exercise_coforall_2.chpl</span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a><span class="ex">./exercise_coforall_2</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>the maximum value in x is: 1.0</code></pre>
</div>
<p>We use the <code>coforall</code> loop to spawn tasks that work
concurrently in a fraction of the array. The trick here is to determine,
based on the <em>taskid</em>, the initial and final indices that the
task will use. Each task obtains the maximum in its fraction of the
array, and finally, after the coforall is done, the main task obtains
the maximum of the array from the maximums of all tasks.</p>
</div>
</div>
</div>
</div>
<div id="try-this-1" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="try-this-1" class="callout-inner">
<h3 class="callout-title">Try this …</h3>
<div class="callout-content">
<p>Substitute the code to find <em>mymax</em> in the last exercise
with:</p>
<pre class="chpl"><code>mymax=max reduce x;</code></pre>
<p>Time the execution of the original code and this new one. How do they
compare?</p>
</div>
</div>
</div>
<div id="callout4" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Callout</h3>
<div class="callout-content">
<p>It is always a good idea to check whether there is <em>built-in</em>
functions or methods in the used language, that can do what we want to
do as efficiently (or better) than our house-made code. In this case,
the <em>reduce</em> statement reduces the given array to a single number
using the given operation (in this case max), and it is parallelized and
optimised to have a very good performance.</p>
</div>
</div>
</div>
<p>The code in these last Exercises somehow <em>synchronise</em> the
tasks to obtain the desired result. In addition, Chapel has specific
mechanisms task synchronisation, that could help us to achieve
fine-grained parallelization.</p>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>“Use <code>begin</code> or <code>cobegin</code> or
<code>coforall</code> to spawn new tasks.”</li>
<li>“You can run more than one task per core, as the number of cores on
a node is limited.”</li>
</ul>
</div>
</div>
</div></section><section id="aio-13-synchronization"><p>Content from <a href="13-synchronization.html">Synchronising tasks</a></p>
<hr>
<p>Last updated on 2024-10-08 |

        <a href="https://github.com/hpc-carpentry/hpc-chapel/edit/main/episodes/13-synchronization.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 90 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>“How should I access my data in parallel?”</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>“Learn how to synchronize multiple threads using one of three
mechanisms: <code>sync</code> statements, sync variables, and atomic
variables.”</li>
<li>“Learn that with shared memory access from multiple threads you can
run into race conditions and deadlocks, and learn how to recognize and
solve these problems.”</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<p>In Chapel the keyword <code>sync</code> can be either a statement or
a type qualifier, providing two different synchronization mechanisms for
threads. Let’s start with using <code>sync</code> as a statement.</p>
<p>As we saw in the previous section, the <code>begin</code> statement
will start a concurrent (or <em>child</em>) task that will run in a
different thread while the main (or <em>parent</em>) thread continues
its normal execution. In this sense the <code>begin</code> statement is
non-blocking. If you want to pause the execution of the main thread and
wait until the child thread ends, you can prepend the <code>begin</code>
statement with the <code>sync</code> statement. Consider the following
code; running this code, after the initial output line, you will first
see all output from thread 1 and only then the line “The first task is
done…” and the rest of the output:</p>
<pre class="chpl"><code>var x=0;
writeln("This is the main thread starting a synchronous task");

sync
{
  begin
  {
    var c=0;
    while c&lt;10
    {
      c+=1;
      writeln('thread 1: ',x+c);
    }
  }
}
writeln("The first task is done...");

writeln("This is the main thread starting an asynchronous task");
begin
{
  var c=0;
  while c&lt;10
  {
    c+=1;
    writeln('thread 2: ',x+c);
  }
}

writeln('this is main thread, I am done...');</code></pre>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="ex">chpl</span> sync_example_1.chpl</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="ex">./sync_example_1</span> </span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>This is the main thread starting a synchronous task
thread 1: 1
thread 1: 2
thread 1: 3
thread 1: 4
thread 1: 5
thread 1: 6
thread 1: 7
thread 1: 8
thread 1: 9
thread 1: 10
The first task is done...
This is the main thread starting an asynchronous task
this is main thread, I am done...
thread 2: 1
thread 2: 2
thread 2: 3
thread 2: 4
thread 2: 5
thread 2: 6
thread 2: 7
thread 2: 8
thread 2: 9
thread 2: 10</code></pre>
</div>
<div id="discussion" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="discussion" class="callout-inner">
<h3 class="callout-title">Discussion</h3>
<div class="callout-content">
<p>What would happen if we write instead</p>
<pre class="chpl"><code>begin
{
  sync
  {
    var c=0;
    while c&lt;10
    {
      c+=1;
      writeln('thread 1: ',x+c);
    }
  }
}
writeln("The first task is done...");</code></pre>
</div>
</div>
</div>
<div id="challenge-3-can-you-do-it" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-3-can-you-do-it" class="callout-inner">
<h3 class="callout-title">Challenge 3: Can you do it?</h3>
<div class="callout-content">
<p>Use <code>begin</code> and <code>sync</code> statements to reproduce
the functionality of <code>cobegin</code> in
<code>cobegin_example.chpl</code>.</p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<pre class="chpl"><code>var x=0;
writeln("This is the main thread, my value of x is ",x);

sync
{
    begin
    {
       var x=5;
       writeln("this is task 1, my value of x is ",x);
    }
    begin writeln("this is task 2, my value of x is ",x);
 }

writeln("this message won't appear until all tasks are done...");</code></pre>
</div>
</div>
</div>
</div>
<p>A more elaborated and powerful use of <code>sync</code> is as a type
qualifier for variables. When a variable is declared as <em>sync</em>, a
state that can be <strong><em>full</em></strong> or
<strong><em>empty</em></strong> is associated to it.</p>
<p>To assign a new value to a <em>sync</em> variable, its state must be
<em>empty</em> (after the assignment operation is completed, the state
will be set as <em>full</em>). On the contrary, to read a value from a
<em>sync</em> variable, its state must be <em>full</em> (after the read
operation is completed, the state will be set as <em>empty</em>
again).</p>
<p>Starting from Chapel 2.x, you must use functions <code>writeEF</code>
and <code>readFF</code> to perform blocking write and read with sync
variables. Below is an example to demonstrate the use of sync variables.
Here we launch a new task that is busy for a short time executing the
loop. While this loop is running, the main task continues printing the
message “this is main task after launching new task… I will wait until
it is done”. As it takes time to spawn a new thread, it is very likely
that you will see this message before the output from the loop. Next,
the main task will attempt to read <code>x</code> and assign it to
<code>a</code> which it can only do when <code>x</code> is full. We
write into <code>x</code> after the loop, so you will see the final
message “and now it is done” only after the message “New task finished”.
In other words, reading <code>x</code>, we pause the execution of the
main thread.</p>
<pre class="chpl"><code>var x: sync int, a: int;
writeln("this is main task launching a new task");
begin {
  for i in 1..10 do writeln("this is new task working: ",i);
  x.writeEF(2);   // assign 2 to x
  writeln("New task finished");
}

writeln("this is main task after launching new task... I will wait until it is done");
a = x.readFE();   // don't run this line until the variable x is written in the other task
writeln("and now it is done");</code></pre>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="ex">chpl</span> sync_example_2.chpl</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="ex">./sync_example_2</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>this is main task launching a new task
this is main task after launching new task... I will wait until it is done
this is new task working: 1
this is new task working: 2
this is new task working: 3
this is new task working: 4
this is new task working: 5
this is new task working: 6
this is new task working: 7
this is new task working: 8
this is new task working: 9
this is new task working: 10
New task finished
and now it is done</code></pre>
</div>
<div id="discussion-1" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="discussion-1" class="callout-inner">
<h3 class="callout-title">Discussion</h3>
<div class="callout-content">
<p>What would happen if we try to read <code>x</code> inside the new
task as well, i.e. we have the following <code>begin</code> statement,
without changing the rest of the code:</p>
<pre class="chpl"><code>begin {
  for i in 1..10 do writeln("this is new task working: ",i);
  x.writeEF(2);
  writeln("New task finished");
  x.readFE();
}</code></pre>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" aria-labelledby="headingSolution2" data-bs-parent="#accordionSolution2">
<div class="accordion-body">
<p>The code will block (run forever), and you would need to press
<em>Ctrl-C</em> to halt its execution. In this example we try to read
<code>x</code> in two places: the main task and the new task. When we
read a sync variable with <code>readFE</code>, the state of the sync
variable is set to empty when this method completes. In other words, one
of the two <code>readFE</code> calls will succeed (which one – depends
on the runtime) and will mark the variable as empty. The other
<code>readFE</code> will then attempt to read it but it will block
waiting for <code>x</code> to become full again (which will never
happen). In the end, the execution of either the main thread or the
child thread will block, hanging the entire code.</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<p>There are a number of methods defined for <em>sync</em> variables. If
<code>x</code> is a sync variable of a given type, you can use the
following functions:</p>
<pre class="chpl"><code>// non-blocking methods
x.reset()	//will set the state as empty and the value as the default of x's type
x.isfull()	//will return true is the state of x is full, false if it is empty

//blocking read and write methods
x.writeEF(value)	//will block until the state of x is empty,
			//then will assign the value,  and set the state to full
x.writeFF(value)	//will block until the state of x is full,
			//then will assign the value, and leave the state as full
x.readFE()		//will block until the state of x is full,
			//then will return x's value, and set the state to empty
x.readFF()		//will block until the state of x is full,
			//then will return x's value, and leave the state as full

//non-blocking read and write methods
x.writeXF(value)	//will assign the value no matter the state of x, and then set the state as full
x.readXX()		//will return the value of x regardless its state. The state will remain unchanged</code></pre>
<p>Chapel also implements <strong><em>atomic</em></strong> operations
with variables declared as <code>atomic</code>, and this provides
another option to synchronise tasks. Atomic operations run completely
independently of any other thread or process. This means that when
several tasks try to write an atomic variable, only one will succeed at
a given moment, providing implicit synchronisation between them. There
is a number of methods defined for atomic variables, among them
<code>sub()</code>, <code>add()</code>, <code>write()</code>,
<code>read()</code>, and <code>waitfor()</code> are very useful to
establish explicit synchronisation between tasks, as showed in the next
code:</p>
<pre class="chpl"><code>var lock: atomic int;
const numtasks=5;

lock.write(0);  //the main task set lock to zero

coforall id in 1..numtasks
{
    writeln("greetings from task ",id,"... I am waiting for all tasks to say hello");
    lock.add(1);                //task id says hello and atomically adds 1 to lock
    lock.waitFor(numtasks);     //then it waits for lock to be equal numtasks (which will happen when all tasks say hello)
    writeln("task ",id," is done...");
}</code></pre>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="ex">chpl</span> atomic_example.chpl</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a><span class="ex">./atomic_example</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>greetings from task 4... I am waiting for all tasks to say hello
greetings from task 5... I am waiting for all tasks to say hello
greetings from task 2... I am waiting for all tasks to say hello
greetings from task 3... I am waiting for all tasks to say hello
greetings from task 1... I am waiting for all tasks to say hello
task 1 is done...
task 5 is done...
task 2 is done...
task 3 is done...
task 4 is done...</code></pre>
</div>
<blockquote>
<h2 id="try-this">Try this…</h2>
<p>Comment out the line <code>lock.waitfor(numtasks)</code> in the code
above to clearly observe the effect of the task synchronisation.</p>
</blockquote>
<p>Finally, with all the material studied so far, we should be ready to
parallelize our code for the simulation of the heat transfer
equation.</p>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>“You can explicitly synchronise tasks with <code>sync</code>
statement.”</li>
<li>“You can also use sync and atomic variables to synchronise
tasks.”</li>
</ul>
</div>
</div>
</div></section><section id="aio-14-parallel-case-study"><p>Content from <a href="14-parallel-case-study.html">Task parallelism with Chapel</a></p>
<hr>
<p>Last updated on 2024-10-08 |

        <a href="https://github.com/hpc-carpentry/hpc-chapel/edit/main/episodes/14-parallel-case-study.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 90 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>“How do I write parallel code for a real use case?”</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>“First objective.”</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<p>Here is our plan to task-parallelize the heat transfer equation:</p>
<ol style="list-style-type: decimal">
<li>divide the entire grid of points into blocks and assign blocks to
individual tasks,</li>
<li>each task should compute the new temperature of its assigned
points,</li>
<li>perform a <strong><em>reduction</em></strong> over the whole grid,
to update the greatest temperature difference between
<code>temp_new</code> and <code>temp</code>.</li>
</ol>
<p>For the reduction of the grid we can simply use the
<code>max reduce</code> statement, which is already parallelized. Now,
let’s divide the grid into <code>rowtasks</code> x <code>coltasks</code>
sub-grids, and assign each sub-grid to a task using the
<code>coforall</code> loop (we will have <code>rowtasks*coltasks</code>
tasks in total).</p>
<pre class="chpl"><code>config const rowtasks = 2;
config const coltasks = 2;

// this is the main loop of the simulation
delta = tolerance;
while (c&lt;niter &amp;&amp; delta&gt;=tolerance) do {
  c += 1;

  coforall taskid in 0..coltasks*rowtasks-1 do {
    for i in rowi..rowf do {
      for j in coli..colf do {
        temp_new[i,j] = (temp[i-1,j] + temp[i+1,j] + temp[i,j-1] + temp[i,j+1]) / 4;
      }
    }
  }

  delta = max reduce (temp_new-temp);
  temp = temp_new;

  if c%outputFrequency == 0 then writeln('Temperature at iteration ',c,': ',temp[x,y]);
}</code></pre>
<p>Note that now the nested <code>for</code> loops run from
<code>rowi</code> to <code>rowf</code> and from <code>coli</code> to
<code>colf</code> which are, respectively, the initial and final row and
column of the sub-grid associated to the task <code>taskid</code>. To
compute these limits, based on <code>taskid</code>, we need to compute
the number of rows and columns per task (<code>nr</code> and
<code>nc</code>, respectively) and account for possible non-zero
remainders (<code>rr</code> and <code>rc</code>) that we should add to
the last row and column:</p>
<pre class="chpl"><code>config const rowtasks = 2;
config const coltasks = 2;

const nr = rows/rowtasks;
const rr = rows-nr*rowtasks;
const nc = cols/coltasks;
const rc = cols-nc*coltasks;

// this is the main loop of the simulation
delta = tolerance;
while (c&lt;niter &amp;&amp; delta&gt;=tolerance) do {
  c+=1;

  coforall taskid in 0..coltasks*rowtasks-1 do {
    var rowi, coli, rowf, colf: int;
    var taskr, taskc: int;

    taskr = taskid/coltasks;
    taskc = taskid%coltasks;

    if taskr&lt;rr then {
      rowi=(taskr*nr)+1+taskr;
      rowf=(taskr*nr)+nr+taskr+1;
    }
    else {
      rowi = (taskr*nr)+1+rr;
      rowf = (taskr*nr)+nr+rr;
    }

    if taskc&lt;rc then {
      coli = (taskc*nc)+1+taskc;
      colf = (taskc*nc)+nc+taskc+1;
    }
    else {
      coli = (taskc*nc)+1+rc;
      colf = (taskc*nc)+nc+rc;
    }

    for i in rowi..rowf do {
      for j in coli..colf do {
      ...
}</code></pre>
<p>As you can see, to divide a data set (the array <code>temp</code> in
this case) between concurrent tasks, could be cumbersome. Chapel
provides high-level abstractions for data parallelism that take care of
all the data distribution for us. We will study data parallelism in the
following lessons, but for now, let’s compare the benchmark solution
with our <code>coforall</code> parallelization to see how the
performance improved.</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="ex">chpl</span> <span class="at">--fast</span> parallel1.chpl</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a><span class="ex">./parallel1</span> <span class="at">--rows</span><span class="op">=</span>650 <span class="at">--cols</span><span class="op">=</span>650 <span class="at">--x</span><span class="op">=</span>200 <span class="at">--y</span><span class="op">=</span>300 <span class="at">--niter</span><span class="op">=</span>10000 <span class="at">--tolerance</span><span class="op">=</span>0.002 <span class="at">--outputFrequency</span><span class="op">=</span>1000</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>The simulation will consider a matrix of 650 by 650 elements,
it will run up to 10000 iterations, or until the largest difference
in temperature between iterations is less than 0.002.
You are interested in the evolution of the temperature at the position (200,300) of the matrix...

and here we go...
Temperature at iteration 0: 25.0
Temperature at iteration 1000: 25.0
Temperature at iteration 2000: 25.0
Temperature at iteration 3000: 25.0
Temperature at iteration 4000: 24.9998
Temperature at iteration 5000: 24.9984
Temperature at iteration 6000: 24.9935
Temperature at iteration 7000: 24.9819

The simulation took 17.0193 seconds
Final temperature at the desired position after 7750 iterations is: 24.9671
The greatest difference in temperatures between the last two iterations was: 0.00199985</code></pre>
</div>
<p>This parallel solution, using 4 parallel tasks, took around 17
seconds to finish. Compared with the ~20 seconds needed by the benchmark
solution, seems not very impressive. To understand the reason, let’s
analyse the code’s flow. When the program starts, the main thread does
all the declarations and initialisations, and then, it enters the main
loop of the simulation (the <strong><em>while loop</em></strong>).
Inside this loop, the parallel tasks are launched for the first time.
When these tasks finish their computations, the main task resumes its
execution, it updates <code>delta</code>, and everything is repeated
again. So, in essence, parallel tasks are launched and resumed 7750
times, which introduces a significant amount of overhead (the time the
system needs to effectively start and destroy threads in the specific
hardware, at each iteration of the while loop).</p>
<p>Clearly, a better approach would be to launch the parallel tasks just
once, and have them executing all the simulations, before resuming the
main task to print the final results.</p>
<pre class="chpl"><code>config const rowtasks = 2;
config const coltasks = 2;

const nr = rows/rowtasks;
const rr = rows-nr*rowtasks;
const nc = cols/coltasks;
const rc = cols-nc*coltasks;

// this is the main loop of the simulation
delta = tolerance;
coforall taskid in 0..coltasks*rowtasks-1 do {
  var rowi, coli, rowf, colf: int;
  var taskr, taskc: int;
  var c = 0;

  taskr = taskid/coltasks;
  taskc = taskid%coltasks;

  if taskr&lt;rr then {
    rowi = (taskr*nr)+1+taskr;
    rowf = (taskr*nr)+nr+taskr+1;
  }
  else {
    rowi = (taskr*nr)+1+rr;
    rowf = (taskr*nr)+nr+rr;
  }

  if taskc&lt;rc then {
    coli = (taskc*nc)+1+taskc;
    colf = (taskc*nc)+nc+taskc+1;
  }
  else {
    coli = (taskc*nc)+1+rc;
    colf = (taskc*nc)+nc+rc;
  }

  while (c&lt;niter &amp;&amp; delta&gt;=tolerance) do {
    c = c+1;

    for i in rowi..rowf do {
      for j in coli..colf do {
        temp_new[i,j] = (temp[i-1,j] + temp[i+1,j] + temp[i,j-1] + temp[i,j+1]) / 4;
      }
    }

    //update delta
    //update temp
    //print temperature in desired position
  }
}</code></pre>
<p>The problem with this approach is that now we have to explicitly
synchronise the tasks. Before, <code>delta</code> and <code>temp</code>
were updated only by the main task at each iteration; similarly, only
the main task was printing results. Now, all these operations must be
carried inside the coforall loop, which imposes the need of
synchronisation between tasks.</p>
<p>The synchronisation must happen at two points:</p>
<ol style="list-style-type: decimal">
<li>We need to be sure that all tasks have finished with the
computations of their part of the grid <code>temp</code>, before
updating <code>delta</code> and <code>temp</code> safely.</li>
<li>We need to be sure that all tasks use the updated value of
<code>delta</code> to evaluate the condition of the while loop for the
next iteration.</li>
</ol>
<p>To update <code>delta</code> we could have each task computing the
greatest difference in temperature in its associated sub-grid, and then,
after the synchronisation, have only one task reducing all the
sub-grids’ maximums.</p>
<pre class="chpl"><code>var delta: atomic real;
var myd: [0..coltasks*rowtasks-1] real;
...
//this is the main loop of the simulation
delta.write(tolerance);
coforall taskid in 0..coltasks*rowtasks-1 do
{
  var myd2: real;
  ...

  while (c&lt;niter &amp;&amp; delta&gt;=tolerance) do {
    c = c+1;
    ...

    for i in rowi..rowf do {
      for j in coli..colf do {
        temp_new[i,j] = (temp[i-1,j] + temp[i+1,j] + temp[i,j-1] + temp[i,j+1]) / 4;
        myd2 = max(abs(temp_new[i,j]-temp[i,j]),myd2);
      }
    }
    myd[taskid] = myd2

    // here comes the synchronisation of tasks

    temp[rowi..rowf,coli..colf] = temp_new[rowi..rowf,coli..colf];
    if taskid==0 then {
      delta.write(max reduce myd);
      if c%outputFrequency==0 then writeln('Temperature at iteration ',c,': ',temp[x,y]);
    }

    // here comes the synchronisation of tasks again
  }
}</code></pre>
<div id="challenge-4-can-you-do-it" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-4-can-you-do-it" class="callout-inner">
<h3 class="callout-title">Challenge 4: Can you do it?</h3>
<div class="callout-content">
<p>Use <code>sync</code> or <code>atomic</code> variables to implement
the synchronisation required in the code above.</p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<p>One possible solution is to use an atomic variable as a <em>lock</em>
that opens (using the <code>waitFor</code> method) when all the tasks
complete the required instructions</p>
<pre class="chpl"><code>var lock: atomic int;
lock.write(0);
...
//this is the main loop of the simulation
delta.write(tolerance);
coforall taskid in 0..coltasks*rowtasks-1 do
{
   ...
   while (c&lt;niter &amp;&amp; delta&gt;=tolerance) do
   {
      ...
      myd[taskid]=myd2

      //here comes the synchronisation of tasks
      lock.add(1);
      lock.waitFor(coltasks*rowtasks);

      temp[rowi..rowf,coli..colf] = temp_new[rowi..rowf,coli..colf];
      ...

      //here comes the synchronisation of tasks again
      lock.sub(1);
      lock.waitFor(0);
   }
}</code></pre>
</div>
</div>
</div>
</div>
<p>Using the solution in the Exercise 4, we can now compare the
performance with the benchmark solution</p>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="ex">chpl</span> <span class="at">--fast</span> parallel2.chpl</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a><span class="ex">./parallel2</span> <span class="at">--rows</span><span class="op">=</span>650 <span class="at">--cols</span><span class="op">=</span>650 <span class="at">--x</span><span class="op">=</span>200 <span class="at">--y</span><span class="op">=</span>300 <span class="at">--niter</span><span class="op">=</span>10000 <span class="at">--tolerance</span><span class="op">=</span>0.002 <span class="at">--outputFrequency</span><span class="op">=</span>1000</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>The simulation will consider a matrix of 650 by 650 elements,
it will run up to 10000 iterations, or until the largest difference
in temperature between iterations is less than 0.002.
You are interested in the evolution of the temperature at the position (200,300) of the matrix...

and here we go...
Temperature at iteration 0: 25.0
Temperature at iteration 1000: 25.0
Temperature at iteration 2000: 25.0
Temperature at iteration 3000: 25.0
Temperature at iteration 4000: 24.9998
Temperature at iteration 5000: 24.9984
Temperature at iteration 6000: 24.9935
Temperature at iteration 7000: 24.9819

The simulation took 4.2733 seconds
Final temperature at the desired position after 7750 iterations is: 24.9671
The greatest difference in temperatures between the last two iterations was: 0.00199985</code></pre>
</div>
<p>to see that we now have a code that performs 5x faster.</p>
<p>We finish this section by providing another, elegant version of the
2D heat transfer solver (without time stepping) using data parallelism
on a single locale:</p>
<pre class="chpl"><code>const n = 100, stride = 20;
var temp: [0..n+1, 0..n+1] real;
var temp_new: [1..n,1..n] real;
var x, y: real;
for (i,j) in {1..n,1..n} { // serial iteration
  x = ((i:real)-0.5)/n;
  y = ((j:real)-0.5)/n;
  temp[i,j] = exp(-((x-0.5)**2 + (y-0.5)**2)/0.01); // narrow Gaussian peak
}
coforall (i,j) in {1..n,1..n} by (stride,stride) { // 5x5 decomposition into 20x20 blocks =&gt; 25 tasks
  for k in i..i+stride-1 { // serial loop inside each block
    for l in j..j+stride-1 do {
      temp_new[k,l] = (temp[k-1,l] + temp[k+1,l] + temp[k,l-1] + temp[k,l+1]) / 4;
    }
  }
}</code></pre>
<p>We will study data parallelism in more detail in the next
section.</p>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>“To parallelize the diffusion solver with tasks, you divide the 2D
domain into blocks and assign each block to a task.”</li>
<li>“To get the maximum performance, you need to launch the parallel
tasks only once, and run the temporal loop of the simulation with the
same set of tasks, resuming the main task only to print the final
results.”</li>
<li>“Parallelizing with tasks is more laborious than parallelizing with
data (covered in the next section).”</li>
</ul>
</div>
</div>
</div></section><section id="aio-21-locales"><p>Content from <a href="21-locales.html">Running code on multiple machines</a></p>
<hr>
<p>Last updated on 2024-10-08 |

        <a href="https://github.com/hpc-carpentry/hpc-chapel/edit/main/episodes/21-locales.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 180 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>“What is a locale?”</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>“First objective.”</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<p>So far we have been working with single-locale Chapel codes that may
run on one or many cores on a single compute node, making use of the
shared memory space and accelerating computations by launching
concurrent tasks on individual cores in parallel. Chapel codes can also
run on multiple nodes on a compute cluster. In Chapel this is referred
to as <em>multi-locale</em> execution.</p>
<p>If you work inside a Chapel Docker container, e.g.,
chapel/chapel-gasnet, the container environment simulates a multi-locale
cluster, so you would compile and launch multi-locale Chapel codes
directly by specifying the number of locales with <code>-nl</code>
flag:</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="ex">chpl</span> <span class="at">--fast</span> mycode.chpl <span class="at">-o</span> mybinary</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="ex">./mybinary</span> <span class="at">-nl</span> 4</span></code></pre>
</div>
<p>Inside the Docker container on multiple locales your code will not
run any faster than on a single locale, since you are emulating a
virtual cluster, and all tasks run on the same physical node. To achieve
actual speedup, you need to run your parallel multi-locale Chapel code
on a real physical cluster which we hope you have access to for this
session.</p>
<p>On a real HPC cluster you would need to submit either an interactive
or a batch job asking for several nodes and then run a multi-locale
Chapel code inside that job. In practice, the exact commands depend on
how the multi-locale Chapel was built on the cluster.</p>
<p>When you compile a Chapel code with the multi-locale Chapel compiler,
two binaries will be produced. One is called <code>mybinary</code> and
is a launcher binary used to submit the real executable
<code>mybinary_real</code>. If the Chapel environment is configured
properly with the launcher for the cluster’s physical interconnect
(which might not be always possible due to a number of factors), then
you would simply compile the code and use the launcher binary
<code>mybinary</code> to submit the job to the queue:</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="ex">chpl</span> <span class="at">--fast</span> mycode.chpl <span class="at">-o</span> mybinary</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="ex">./mybinary</span> <span class="at">-nl</span> 2</span></code></pre>
</div>
<p>The exact parameters of the job such as the maximum runtime and the
requested memory can be specified with Chapel environment variables. One
possible drawback of this launching method is that, depending on your
cluster setup, Chapel might have access to all physical cores on each
node participating in the run – this will present problems if you are
scheduling jobs by-core and not by-node, since part of a node should be
allocated to someone else’s job.</p>
<p>Note that on Compute Canada clusters this launching method works
without problem. On these clusters multi-locale Chapel is provided by
<code>chapel-ofi</code> (for the OmniPath interconnect on Cedar) and
<code>chapel-ucx</code> (for the InfiniBand interconnect on Graham,
Béluga, Narval) modules, so – depending on the cluster – you will load
Chapel using one of the two lines below:</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="ex">module</span> load gcc chapel-ofi   <span class="co"># for the OmniPath interconnect on Cedar cluster</span></span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a><span class="ex">module</span> load gcc chapel-ucx   <span class="co"># for the InfiniBand interconnect on Graham, Béluga, Narval clusters</span></span></code></pre>
</div>
<p>We can also launch multi-locale Chapel codes using the real
executable <code>mybinary_real</code>. For example, for an interactive
job you would type:</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="ex">salloc</span> <span class="at">--time</span><span class="op">=</span>0:30:0 <span class="at">--nodes</span><span class="op">=</span>4 <span class="at">--cpus-per-task</span><span class="op">=</span>3 <span class="at">--mem-per-cpu</span><span class="op">=</span>1000 <span class="at">--account</span><span class="op">=</span>def-guest</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a><span class="ex">chpl</span> <span class="at">--fast</span> mycode.chpl <span class="at">-o</span> mybinary</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a><span class="ex">srun</span> ./mybinary_real <span class="at">-nl</span> 4   <span class="co"># will run on four locales with max 3 cores per locale</span></span></code></pre>
</div>
<p>Production jobs would be launched with <code>sbatch</code> command
and a Slurm launch script as usual.</p>
<p>For the rest of this class we assume that you have a working
multi-locale Chapel environment, whether provided by a Docker container
or by multi-locale Chapel on a physical HPC cluster. We will run all
examples on four nodes with three cores per node.</p>
<div class="section level1">
<h1 id="intro-to-multi-locale-code">Intro to multi-locale code<a class="anchor" aria-label="anchor" href="#intro-to-multi-locale-code"></a>
</h1>
<p>Let us test our multi-locale Chapel environment by launching the
following code:</p>
<pre class="chpl"><code><span><span class="fu">writeln</span><span class="op">(</span><span class="va">Locales</span><span class="op">)</span>;</span></code></pre>
<p>This code will print the built-in global array <code>Locales</code>.
Running it on four locales will produce</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>LOCALE0 LOCALE1 LOCALE2 LOCALE3</code></pre>
</div>
<p>We want to run some code on each locale (node). For that, we can
cycle through locales:</p>
<pre class="chpl"><code>for loc in Locales do   // this is still a serial program
  on loc do             // run the next line on locale `loc`
    writeln("this locale is named ", here.name);</code></pre>
<p>This will produce</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>this locale is named cdr544
this locale is named cdr552
this locale is named cdr556
this locale is named cdr692</code></pre>
</div>
<p>Here the built-in variable class <code>here</code> refers to the
locale on which the code is running, and <code>here.name</code> is its
hostname. We started a serial <code>for</code> loop cycling through all
locales, and on each locale we printed its name, i.e., the hostname of
each node. This program ran in serial starting a task on each locale
only after completing the same task on the previous locale. Note the
order in which locales were listed.</p>
<p>To run this code in parallel, starting four simultaneous tasks, one
per locale, we simply need to replace <code>for</code> with
<code>forall</code>:</p>
<pre class="chpl"><code>forall loc in Locales do   // now this is a parallel loop
  on loc do
    writeln("this locale is named ", here.name);</code></pre>
<p>This starts four tasks in parallel, and the order in which the print
statement is executed depends on the runtime conditions and can change
from run to run:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>this locale is named cdr544
this locale is named cdr692
this locale is named cdr556
this locale is named cdr552</code></pre>
</div>
<p>We can print few other attributes of each locale. Here it is actually
useful to revert to the serial loop <code>for</code> so that the print
statements appear in order:</p>
<pre class="chpl"><code>use Memory.Diagnostics;
for loc in Locales do
  on loc {
    writeln("locale #", here.id, "...");
    writeln("  ...is named: ", here.name);
    writeln("  ...has ", here.numPUs(), " processor cores");
    writeln("  ...has ", here.physicalMemory(unit=MemUnits.GB, retType=real), " GB of memory");
    writeln("  ...has ", here.maxTaskPar, " maximum parallelism");
  }</code></pre>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>locale #0...
  ...is named: cdr544
  ...has 3 processor cores
  ...has 125.804 GB of memory
  ...has 3 maximum parallelism
locale #1...
  ...is named: cdr552
  ...has 3 processor cores
  ...has 125.804 GB of memory
  ...has 3 maximum parallelism
locale #2...
  ...is named: cdr556
  ...has 3 processor cores
  ...has 125.804 GB of memory
  ...has 3 maximum parallelism
locale #3...
  ...is named: cdr692
  ...has 3 processor cores
  ...has 125.804 GB of memory
  ...has 3 maximum parallelism</code></pre>
</div>
<p>Note that while Chapel correctly determines the number of cores
available inside our job on each node, and the maximum parallelism
(which is the same as the number of cores available!), it lists the
total physical memory on each node available to all running jobs which
is not the same as the total memory per node allocated to our job.</p>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>“Locale in Chapel is a shared-memory node on a cluster.”</li>
<li>“We can cycle in serial or parallel through all locales.”</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div></section><section id="aio-22-domains"><p>Content from <a href="22-domains.html">Domains and data parallelism</a></p>
<hr>
<p>Last updated on 2024-10-08 |

        <a href="https://github.com/hpc-carpentry/hpc-chapel/edit/main/episodes/22-domains.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 180 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>“How do I store and manipulate data across multiple locales?”</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>“First objective.”</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="section level1">
<h1 id="domains-and-single-locale-data-parallelism">Domains and single-locale data parallelism<a class="anchor" aria-label="anchor" href="#domains-and-single-locale-data-parallelism"></a>
</h1>
<p>We start this section by recalling the definition of a range in
Chapel. A range is a 1D set of integer indices that can be bounded or
infinite:</p>
<pre class="chpl"><code>var oneToTen: range = 1..10; // 1, 2, 3, ..., 10
var a = 1234, b = 5678;
var aToB: range = a..b; // using variables
var twoToTenByTwo: range(stridable=true) = 2..10 by 2; // 2, 4, 6, 8, 10
var oneToInf = 1.. ; // unbounded range</code></pre>
<p>On the other hand, domains are multi-dimensional (including 1D) sets
of integer indices that are always bounded. To stress the difference
between domain ranges and domains, domain definitions always enclose
their indices in curly brackets. Ranges can be used to define a specific
dimension of a domain:</p>
<pre class="chpl"><code>var domain1to10: domain(1) = {1..10};        // 1D domain from 1 to 10 defined using the range 1..10
var twoDimensions: domain(2) = {-2..2,0..2}; // 2D domain over a product of two ranges
var thirdDim: range = 1..16; // a range
var threeDims: domain(3) = {thirdDim, 1..10, 5..10}; // 3D domain over a product of three ranges
for idx in twoDimensions do // cycle through all points in a 2D domain
  write(idx, ", ");
writeln();
for (x,y) in twoDimensions { // can also cycle using explicit tuples (x,y)
  write("(", x, ", ", y, ")", ", ");
}</code></pre>
<p>Let us define an n^2 domain called <code>mesh</code>. It is defined
by the single task in our code and is therefore defined in memory on the
same node (locale 0) where this task is running. For each of n^2 mesh
points, let us print out</p>
<ol style="list-style-type: decimal">
<li>
<code>m.locale.id</code>, the ID of the locale holding that mesh
point (should be 0)</li>
<li>
<code>here.id</code>, the ID of the locale on which the code is
running (should be 0)</li>
<li>
<code>here.maxTaskPar</code>, the number of cores (max parallelism
with 1 task/core) (should be 3)</li>
</ol>
<p><strong>Note</strong>: We already saw some of these
variables/functions: numLocales, Locales, here.id, here.name,
here.numPUs(), here.physicalMemory(), here.maxTaskPar.</p>
<pre class="chpl"><code>config const n = 8;
const mesh: domain(2) = {1..n, 1..n};  // a 2D domain defined in shared memory on a single locale
forall m in mesh { // go in parallel through all n^2 mesh points
  writeln((m, m.locale.id, here.id, here.maxTaskPar));
}</code></pre>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>((7, 1), 0, 0, 3)
((1, 1), 0, 0, 3)
((7, 2), 0, 0, 3)
((1, 2), 0, 0, 3)
...
((6, 6), 0, 0, 3)
((6, 7), 0, 0, 3)
((6, 8), 0, 0, 3)</code></pre>
</div>
<p>Now we are going to learn two very important properties of Chapel
domains. First, domains can be used to define arrays of variables of any
type on top of them. For example, let us define an n^2 array of real
numbers on top of <code>mesh</code>:</p>
<pre class="chpl"><code>config const n = 8;
const mesh: domain(2) = {1..n, 1..n};  // a 2D domain defined in shared memory on a single locale
var T: [mesh] real; // a 2D array of reals defined in shared memory on a single locale (mapped onto this domain)
forall t in T { // go in parallel through all n^2 elements of T
  writeln((t, t.locale.id));
}</code></pre>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>(0.0, 0)
(0.0, 0)
(0.0, 0)
(0.0, 0)
...
(0.0, 0)
(0.0, 0)
(0.0, 0)</code></pre>
</div>
<p>By default, all n^2 array elements are set to zero, and all of them
are defined on the same locale as the underlying mesh. We can also cycle
through all indices of T by accessing its domain:</p>
<pre class="chpl"><code>forall idx in T.domain {
  writeln(idx, ' ', T(idx));   // idx is a tuple (i,j); also print the corresponding array element
}</code></pre>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>(7, 1) 0.0
(1, 1) 0.0
(7, 2) 0.0
(1, 2) 0.0
...
(6, 6) 0.0
(6, 7) 0.0
(6, 8) 0.0</code></pre>
</div>
<p>Since we use a parallel <code>forall</code> loop, the print
statements appear in a random runtime order.</p>
<p>We can also define multiple arrays on the same domain:</p>
<pre class="chpl"><code>const grid = {1..100}; // 1D domain
const alpha = 5; // some number
var A, B, C: [grid] real; // local real-type arrays on this 1D domain
B = 2; C = 3;
forall (a,b,c) in zip(A,B,C) do // parallel loop
  a = b + alpha*c;   // simple example of data parallelism on a single locale
writeln(A);</code></pre>
<p>The second important property of Chapel domains is that they can span
multiple locales (nodes).</p>
<div class="section level2">
<h2 id="distributed-domains">Distributed domains<a class="anchor" aria-label="anchor" href="#distributed-domains"></a>
</h2>
<p>Domains are fundamental Chapel concept for distributed-memory data
parallelism.</p>
<p>Let us now define an n^2 distributed (over several locales) domain
<code>distributedMesh</code> mapped to locales in blocks. On top of this
domain we define a 2D block-distributed array A of strings mapped to
locales in exactly the same pattern as the underlying domain. Let us
print out</p>
<ol style="list-style-type: decimal">
<li>
<code>a.locale.id</code>, the ID of the locale holding the element a
of A</li>
<li>
<code>here.name</code>, the name of the locale on which the code is
running</li>
<li>
<code>here.maxTaskPar</code>, the number of cores on the locale on
which the code is running</li>
</ol>
<p>Instead of printing these values to the screen, we will store this
output inside each element of A as a string
<code>a.locale.id:string + '-' + here.name + '-' + here.maxTaskPar:string</code>,
adding a separator <code>' '</code> at the end of each element.</p>
<pre class="chpl"><code>use BlockDist; // use standard block distribution module to partition the domain into blocks
config const n = 8;
const mesh: domain(2) = {1..n, 1..n};
const distributedMesh: domain(2) dmapped Block(boundingBox=mesh) = mesh;
var A: [distributedMesh] string; // block-distributed array mapped to locales
forall a in A { // go in parallel through all n^2 elements in A
  // assign each array element on the locale that stores that index/element
  a = a.locale.id:string + '-' + here.name + '-' + here.maxTaskPar:string + '  ';
}
writeln(A);</code></pre>
<p>The syntax <code>boundingBox=mesh</code> tells the compiler that the
outer edge of our decomposition coincides exactly with the outer edge of
our domain. Alternatively, the outer decomposition layer could include
an additional perimeter of <em>ghost points</em> if we specify</p>
<pre class="chpl"><code>const mesh: domain(2) = {1..n, 1..n};
const largerMesh: domain(2) dmapped Block(boundingBox=mesh) = {0..n+1,0..n+1};</code></pre>
<p>but let us not worry about this for now.</p>
<p>Running our code on four locales with three cores per locale produces
the following output:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>0-cdr544-3   0-cdr544-3   0-cdr544-3   0-cdr544-3   1-cdr552-3   1-cdr552-3   1-cdr552-3   1-cdr552-3
0-cdr544-3   0-cdr544-3   0-cdr544-3   0-cdr544-3   1-cdr552-3   1-cdr552-3   1-cdr552-3   1-cdr552-3
0-cdr544-3   0-cdr544-3   0-cdr544-3   0-cdr544-3   1-cdr552-3   1-cdr552-3   1-cdr552-3   1-cdr552-3
0-cdr544-3   0-cdr544-3   0-cdr544-3   0-cdr544-3   1-cdr552-3   1-cdr552-3   1-cdr552-3   1-cdr552-3
2-cdr556-3   2-cdr556-3   2-cdr556-3   2-cdr556-3   3-cdr692-3   3-cdr692-3   3-cdr692-3   3-cdr692-3
2-cdr556-3   2-cdr556-3   2-cdr556-3   2-cdr556-3   3-cdr692-3   3-cdr692-3   3-cdr692-3   3-cdr692-3
2-cdr556-3   2-cdr556-3   2-cdr556-3   2-cdr556-3   3-cdr692-3   3-cdr692-3   3-cdr692-3   3-cdr692-3
2-cdr556-3   2-cdr556-3   2-cdr556-3   2-cdr556-3   3-cdr692-3   3-cdr692-3   3-cdr692-3   3-cdr692-3  </code></pre>
</div>
<p>As we see, the domain <code>distributedMesh</code> (along with the
string array <code>A</code> on top of it) was decomposed into 2x2 blocks
stored on the four nodes, respectively. Equally important, for each
element <code>a</code> of the array, the line of code filling in that
element ran on the same locale where that element was stored. In other
words, this code ran in parallel (<code>forall</code> loop) on four
nodes, using up to three cores on each node to fill in the corresponding
array elements. Once the parallel loop is finished, the
<code>writeln</code> command runs on locale 0 gathering remote elements
from other locales and printing them to standard output.</p>
<p>Now we can print the range of indices for each sub-domain by adding
the following to our code:</p>
<pre class="chpl"><code>for loc in Locales {
  on loc {
    writeln(A.localSubdomain());
  }
}</code></pre>
<p>On 4 locales we should get:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>{1..4, 1..4}
{1..4, 5..8}
{5..8, 1..4}
{5..8, 5..8}  </code></pre>
</div>
<p>Let us count the number of threads by adding the following to our
code:</p>
<pre class="chpl"><code>var counter = 0;
forall a in A with (+ reduce counter) { // go in parallel through all n^2 elements
  counter = 1;
}
writeln("actual number of threads = ", counter);</code></pre>
<p>If <code>n=8</code> in our code is sufficiently large, there are
enough array elements per node (8*8/4 = 16 in our case) to fully utilise
all three available cores on each node, so our output should be</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>actual number of threads = 12</code></pre>
</div>
<p>Try reducing the array size <code>n</code> to see if that changes the
output (fewer tasks per locale), e.g., setting n=3. Also try increasing
the array size to n=20 and study the output. Does the output make
sense?</p>
<p>So far we looked at the block distribution <code>BlockDist</code>. It
will distribute a 2D domain among nodes either using 1D or 2D
decomposition (in our example it was 2D decomposition 2x2), depending on
the domain size and the number of nodes.</p>
<p>Let us take a look at another standard module for domain partitioning
onto locales, called CyclicDist. For each element of the array we will
print out again</p>
<ol style="list-style-type: decimal">
<li>
<code>a.locale.id</code>, the ID of the locale holding the element a
of A</li>
<li>
<code>here.name</code>, the name of the locale on which the code is
running</li>
<li>
<code>here.maxTaskPar</code>, the number of cores on the locale on
which the code is running</li>
</ol>
<pre class="chpl"><code>use CyclicDist; // elements are sent to locales in a round-robin pattern
config const n = 8;
const mesh: domain(2) = {1..n, 1..n};  // a 2D domain defined in shared memory on a single locale
const m2: domain(2) dmapped Cyclic(startIdx=mesh.low) = mesh; // mesh.low is the first index (1,1)
var A2: [m2] string;
forall a in A2 {
  a = a.locale.id:string + '-' + here.name + '-' + here.maxTaskPar:string + '  ';
}
writeln(A2);</code></pre>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>0-cdr544-3   1-cdr552-3   0-cdr544-3   1-cdr552-3   0-cdr544-3   1-cdr552-3   0-cdr544-3   1-cdr552-3
2-cdr556-3   3-cdr692-3   2-cdr556-3   3-cdr692-3   2-cdr556-3   3-cdr692-3   2-cdr556-3   3-cdr692-3
0-cdr544-3   1-cdr552-3   0-cdr544-3   1-cdr552-3   0-cdr544-3   1-cdr552-3   0-cdr544-3   1-cdr552-3
2-cdr556-3   3-cdr692-3   2-cdr556-3   3-cdr692-3   2-cdr556-3   3-cdr692-3   2-cdr556-3   3-cdr692-3
0-cdr544-3   1-cdr552-3   0-cdr544-3   1-cdr552-3   0-cdr544-3   1-cdr552-3   0-cdr544-3   1-cdr552-3
2-cdr556-3   3-cdr692-3   2-cdr556-3   3-cdr692-3   2-cdr556-3   3-cdr692-3   2-cdr556-3   3-cdr692-3
0-cdr544-3   1-cdr552-3   0-cdr544-3   1-cdr552-3   0-cdr544-3   1-cdr552-3   0-cdr544-3   1-cdr552-3
2-cdr556-3   3-cdr692-3   2-cdr556-3   3-cdr692-3   2-cdr556-3   3-cdr692-3   2-cdr556-3   3-cdr692-3  </code></pre>
</div>
<p>As the name <code>CyclicDist</code> suggests, the domain was mapped
to locales in a cyclic, round-robin pattern. We can also print the range
of indices for each sub-domain by adding the following to our code:</p>
<pre class="chpl"><code>for loc in Locales {
  on loc {
    writeln(A2.localSubdomain());
  }
}</code></pre>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>{1..7 by 2, 1..7 by 2}
{1..7 by 2, 2..8 by 2}
{2..8 by 2, 1..7 by 2}
{2..8 by 2, 2..8 by 2}</code></pre>
</div>
<p>In addition to BlockDist and CyclicDist, Chapel has several other
predefined distributions: BlockCycDist, ReplicatedDist,
DimensionalDist2D, ReplicatedDim, BlockCycDim — for details please see
<a href="https://chapel-lang.org/docs/primers/distributions.html" class="external-link uri">https://chapel-lang.org/docs/primers/distributions.html</a>.</p>
</div>
<div class="section level2">
<h2 id="diffusion-solver-on-distributed-domains">Diffusion solver on distributed domains<a class="anchor" aria-label="anchor" href="#diffusion-solver-on-distributed-domains"></a>
</h2>
<p>Now let us use distributed domains to write a parallel version of our
original diffusion solver code:</p>
<pre class="chpl"><code>use BlockDist;
config const n = 8;
const mesh: domain(2) = {1..n, 1..n};  // local 2D n^2 domain</code></pre>
<p>We will add a larger (n+2)^2 block-distributed domain
<code>largerMesh</code> with a layer of <em>ghost points</em> on
<em>perimeter locales</em>, and define a temperature array
<code>temp</code> on top of it, by adding the following to our code:</p>
<pre class="chpl"><code>const largerMesh: domain(2) dmapped Block(boundingBox=mesh) = {0..n+1, 0..n+1};
var temp: [largerMesh] real; // a block-distributed array of temperatures
forall (i,j) in T.domain[1..n,1..n] {
  var x = ((i:real)-0.5)/(n:real); // x, y are local to each task
  var y = ((j:real)-0.5)/(n:real);
  temp[i,j] = exp(-((x-0.5)**2 + (y-0.5)**2) / 0.01); // narrow Gaussian peak
}
writeln(temp);</code></pre>
<p>Here we initialised an initial Gaussian temperature peak in the
middle of the mesh. As we evolve our solution in time, this peak should
diffuse slowly over the rest of the domain.</p>
<blockquote>
<h2 id="question">Question</h2>
<p>Why do we have <code>forall (i,j) in T.domain[1..n,1..n]</code> and
not <code>forall (i,j) in mesh</code>?</p>
<blockquote>
<h2 id="answer">Answer</h2>
<p>The first one will run on multiple locales in parallel, whereas the
second will run in parallel via multiple threads on locale 0 only, since
“mesh” is defined on locale 0.</p>
</blockquote>
</blockquote>
<p>The code above will print the initial temperature distribution:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0
0.0 2.36954e-17 2.79367e-13 1.44716e-10 3.29371e-09 3.29371e-09 1.44716e-10 2.79367e-13 2.36954e-17 0.0
0.0 2.79367e-13 3.29371e-09 1.70619e-06 3.88326e-05 3.88326e-05 1.70619e-06 3.29371e-09 2.79367e-13 0.0
0.0 1.44716e-10 1.70619e-06 0.000883826 0.0201158 0.0201158 0.000883826 1.70619e-06 1.44716e-10 0.0
0.0 3.29371e-09 3.88326e-05 0.0201158 0.457833 0.457833 0.0201158 3.88326e-05 3.29371e-09 0.0
0.0 3.29371e-09 3.88326e-05 0.0201158 0.457833 0.457833 0.0201158 3.88326e-05 3.29371e-09 0.0
0.0 1.44716e-10 1.70619e-06 0.000883826 0.0201158 0.0201158 0.000883826 1.70619e-06 1.44716e-10 0.0
0.0 2.79367e-13 3.29371e-09 1.70619e-06 3.88326e-05 3.88326e-05 1.70619e-06 3.29371e-09 2.79367e-13 0.0
0.0 2.36954e-17 2.79367e-13 1.44716e-10 3.29371e-09 3.29371e-09 1.44716e-10 2.79367e-13 2.36954e-17 0.0
0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0  </code></pre>
</div>
<p>Let us define an array of strings <code>nodeID</code> with the same
distribution over locales as <code>temp</code>, by adding the following
to our code:</p>
<pre class="chpl"><code>var nodeID: [largerMesh] string;
forall m in nodeID do
  m = here.id:string;
writeln(nodeID);</code></pre>
<p>The outer perimeter in the partition below are the <em>ghost
points</em>:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>0 0 0 0 0 1 1 1 1 1
0 0 0 0 0 1 1 1 1 1
0 0 0 0 0 1 1 1 1 1
0 0 0 0 0 1 1 1 1 1
0 0 0 0 0 1 1 1 1 1
2 2 2 2 2 3 3 3 3 3
2 2 2 2 2 3 3 3 3 3
2 2 2 2 2 3 3 3 3 3
2 2 2 2 2 3 3 3 3 3
2 2 2 2 2 3 3 3 3 3  </code></pre>
</div>
<div id="challenge-3-can-you-do-it" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-3-can-you-do-it" class="callout-inner">
<h3 class="callout-title">Challenge 3: Can you do it?</h3>
<div class="callout-content">
<p>In addition to here.id, also print the ID of the locale holding that
value. Is it the same or different from here.id?</p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<p>Something along the lines:
<code>m = here.id:string + '-' + m.locale.id:string</code></p>
</div>
</div>
</div>
</div>
<p>Now we implement the parallel solver, by adding the following to our
code (<em>contains a mistake on purpose!</em>):</p>
<pre class="chpl"><code>var temp_new: [largerMesh] real;
for step in 1..5 { // time-stepping
  forall (i,j) in mesh do
    temp_new[i,j] = (temp[i-1,j] + temp[i+1,j] + temp[i,j-1] + temp[i,j+1]) / 4;
  temp[mesh] = temp_new[mesh]; // uses parallel forall underneath
}</code></pre>
<div id="challenge-4-can-you-do-it" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-4-can-you-do-it" class="callout-inner">
<h3 class="callout-title">Challenge 4: Can you do it?</h3>
<div class="callout-content">
<p>Can anyone spot a mistake in the last code?</p>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" data-bs-parent="#accordionSolution2" aria-labelledby="headingSolution2">
<div class="accordion-body">
<p>It should be</p>
<p><code>forall (i,j) in temp_new.domain[1..n,1..n] do</code></p>
<p>instead of</p>
<p><code>forall (i,j) in mesh do</code></p>
<p>as the last one will likely run in parallel via threads only on
locale 0, whereas the former will run on multiple locales in
parallel.</p>
</div>
</div>
</div>
</div>
<p>Here is the final version of the entire code:</p>
<pre class="chpl"><code>use BlockDist;
config const n = 8;
const mesh: domain(2) = {1..n,1..n};
const largerMesh: domain(2) dmapped Block(boundingBox=mesh) = {0..n+1,0..n+1};
var temp, temp_new: [largerMesh] real;
forall (i,j) in temp.domain[1..n,1..n] {
  var x = ((i:real)-0.5)/(n:real);
  var y = ((j:real)-0.5)/(n:real);
  temp[i,j] = exp(-((x-0.5)**2 + (y-0.5)**2) / 0.01);
}
for step in 1..5 {
  forall (i,j) in temp_new.domain[1..n,1..n] {
    temp_new[i,j] = (temp[i-1,j] + temp[i+1,j] + temp[i,j-1] + temp[i,j+1]) / 4.0;
  }
  temp = temp_new;
  writeln((step, " ", temp[n/2,n/2], " ", temp[1,1]));
}</code></pre>
<p>This is the entire parallel solver! Note that we implemented an open
boundary: <code>temp</code> on the <em>ghost points</em> is always 0.
Let us add some printout and also compute the total energy on the mesh,
by adding the following to our code:</p>
<pre class="chpl"><code>  writeln((step, " ", temp[n/2,n/2], " ", temp[2,2]));
  var total: real = 0;
  forall (i,j) in mesh with (+ reduce total) do
    total += temp[i,j];
  writeln("total = ", total);</code></pre>
<p>Notice how the total energy decreases in time with the open boundary
conditions, as the energy is leaving the system.</p>
<div id="challenge-5-can-you-do-it" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-5-can-you-do-it" class="callout-inner">
<h3 class="callout-title">Challenge 5: Can you do it?</h3>
<div class="callout-content">
<p>Write a code to print how the finite-difference stencil [i,j],
[i-1,j], [i+1,j], [i,j-1], [i,j+1] is distributed among nodes, and
compare that to the ID of the node where temp[i,i] is computed.</p>
</div>
</div>
</div>
<div id="accordionSolution3" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution3" aria-expanded="false" aria-controls="collapseSolution3">
  <h4 class="accordion-header" id="headingSolution3"> Show me the solution </h4>
</button>
<div id="collapseSolution3" class="accordion-collapse collapse" data-bs-parent="#accordionSolution3" aria-labelledby="headingSolution3">
<div class="accordion-body">
<p>Here is one possible solution examining the locality of the
finite-difference stencil:</p>
<pre class="chpl"><code>var nodeID: [largerMesh] string = 'empty';
forall (i,j) in nodeID.domain[1..n,1..n] do
  nodeID[i,j] = here.id:string + nodeID[i,j].locale.id:string + nodeID[i-1,j].locale.id:string +
    nodeID[i+1,j].locale.id:string + nodeID[i,j-1].locale.id:string + nodeID[i,j+1].locale.id:string + '  ';
writeln(nodeID);</code></pre>
</div>
</div>
</div>
</div>
<p>This produced the following output clearly showing the <em>ghost
points</em> and the stencil distribution for each mesh point:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>empty empty empty empty empty empty empty empty empty empty
empty 000000   000000   000000   000001   111101   111111   111111   111111   empty
empty 000000   000000   000000   000001   111101   111111   111111   111111   empty
empty 000000   000000   000000   000001   111101   111111   111111   111111   empty
empty 000200   000200   000200   000201   111301   111311   111311   111311   empty
empty 220222   220222   220222   220223   331323   331333   331333   331333   empty
empty 222222   222222   222222   222223   333323   333333   333333   333333   empty
empty 222222   222222   222222   222223   333323   333333   333333   333333   empty
empty 222222   222222   222222   222223   333323   333333   333333   333333   empty
empty empty empty empty empty empty empty empty empty empty</code></pre>
</div>
<p>Note that temp[i,j] is always computed on the same node where that
element is stored, which makes sense.</p>
</div>
<div class="section level2">
<h2 id="periodic-boundary-conditions">Periodic boundary conditions<a class="anchor" aria-label="anchor" href="#periodic-boundary-conditions"></a>
</h2>
<p>Now let us modify the previous parallel solver to include periodic
BCs. At the beginning of each time step we need to set elements on the
<em>ghost points</em> to their respective values on the <em>opposite
ends</em>, by adding the following to our code:</p>
<pre class="chpl"><code>  temp[0,1..n] = temp[n,1..n]; // periodic boundaries on all four sides; these will run via parallel forall
  temp[n+1,1..n] = temp[1,1..n];
  temp[1..n,0] = temp[1..n,n];
  temp[1..n,n+1] = temp[1..n,1];</code></pre>
<p>Now total energy should be conserved, as nothing leaves the
domain.</p>
</div>
</div>
<div class="section level1">
<h1 id="io">I/O<a class="anchor" aria-label="anchor" href="#io"></a>
</h1>
<p>Let us write the final solution to disk. There are several
caveats:</p>
<ul>
<li>works only with ASCII</li>
<li>Chapel can also write binary data but nothing can read it (checked:
not the endians problem!)</li>
<li>would love to write NetCDF and HDF5, probably can do this by calling
C/C++ functions from Chapel</li>
</ul>
<p>We’ll add the following to our code to write ASCII:</p>
<pre class="chpl"><code>use IO;
var myFile = open("output.dat", iomode.cw); // open the file for writing
var myWritingChannel = myFile.writer(); // create a writing channel starting at file offset 0
myWritingChannel.write(temp); // write the array
myWritingChannel.close(); // close the channel</code></pre>
<p>Run the code and check the file <em>output.dat</em>: it should
contain the array T after 5 steps in ASCII.</p>
<!-- # Ideas for future topics or homework -->
<!-- - binary I/O -->
<!-- - write/read NetCDF from Chapel by calling a C/C++ function -->
<!-- - take a simple non-linear problem, linearise it, implement a parallel -->
<!--   multi-locale linear solver entirely in Chapel -->
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>“Domains are multi-dimensional sets of integer indices.”</li>
<li>“A domain can be defined on a single locale or distributed across
many locales.”</li>
<li>“There are many predefined distribution method: block, cyclic,
etc.”</li>
<li>“Arrays are defined on top of domains and inherit their distribution
model.”</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div></section>
</div>
    </main>
</div>
<!-- END  : inst/pkgdown/templates/content-extra.html -->

      </div>
<!--/div.row-->
      		<footer class="row footer mx-md-3"><hr>
<div class="col-md-6">
        <p>This lesson is subject to the <a href="CODE_OF_CONDUCT.html">Code of Conduct</a></p>
        <p>

        <a href="https://github.com/hpc-carpentry/hpc-chapel/edit/main/README.md" class="external-link">Edit on GitHub</a>

	
        | <a href="https://github.com/hpc-carpentry/hpc-chapel/blob/main/CONTRIBUTING.md" class="external-link">Contributing</a>
        | <a href="https://github.com/hpc-carpentry/hpc-chapel/" class="external-link">Source</a></p>
				<p><a href="https://github.com/hpc-carpentry/hpc-chapel/blob/main/CITATION.cff" class="external-link">Cite</a> | <a href="mailto:maintainers-hpc@lists.carpentries.org">Contact</a> | <a href="https://carpentries.org/about/" class="external-link">About</a></p>
			</div>
			<div class="col-md-6">

        <p>Materials licensed under <a href="LICENSE.html">CC-BY 4.0</a> by the authors</p>

        <p>Template licensed under <a href="https://creativecommons.org/licenses/by-sa/4.0/" class="external-link">CC-BY 4.0</a> by <a href="https://carpentries.org/" class="external-link">The Carpentries</a></p>
        <p>Built with <a href="https://github.com/carpentries/sandpaper/tree/0.16.9" class="external-link">sandpaper (0.16.9)</a>, <a href="https://github.com/carpentries/pegboard/tree/0.7.6" class="external-link">pegboard (0.7.6)</a>, and <a href="https://github.com/carpentries/varnish/tree/1.0.4" class="external-link">varnish (1.0.4)</a></p>
			</div>
		</footer>
</div> <!-- / div.container -->
	<div id="to-top">
		<a href="#top">
      <i class="search-icon" data-feather="arrow-up" role="img" aria-label="Back To Top"></i><br><!-- <span class="d-none d-sm-none d-md-none d-lg-none d-xl-block">Back</span> To Top --><span class="d-none d-sm-none d-md-none d-lg-none d-xl-block">Back</span> To Top
		</a>
	</div>
  <script type="application/ld+json">
    {
  "@context": "https://schema.org",
  "@type": "TrainingMaterial",
  "@id": "https://hpc-carpentry.github.io/hpc-chapel/instructor/aio.html",
  "inLanguage": "en",
  "dct:conformsTo": "https://bioschemas.org/profiles/TrainingMaterial/1.0-RELEASE",
  "description": "A Carpentries Lesson teaching foundational data and coding skills to researchers worldwide",
  "keywords": "software, data, lesson, The Carpentries, HPC, Chapel",
  "name": "All in One View",
  "creativeWorkStatus": "active",
  "url": "https://hpc-carpentry.github.io/hpc-chapel/instructor/aio.html",
  "identifier": "https://hpc-carpentry.github.io/hpc-chapel/instructor/aio.html",
  "dateCreated": "2017-09-14",
  "dateModified": "2024-10-29",
  "datePublished": "2024-10-29"
}

  </script><script>
		feather.replace();
	</script>
</body>
</html><!-- END:   inst/pkgdown/templates/layout.html-->

